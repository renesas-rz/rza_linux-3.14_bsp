diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 8017cde..ed11d2b 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -173,7 +173,7 @@ not_angel:
 #ifdef CONFIG_AUTO_ZRELADDR
 		@ determine final kernel image address
 		mov	r4, pc
-		and	r4, r4, #0xf8000000
+		and	r4, r4, #0xfc000000
 		add	r4, r4, #TEXT_OFFSET
 #else
 		ldr	r4, =zreladdr
diff --git a/arch/arm/boot/dts/r7s72100-rskrza1.dts b/arch/arm/boot/dts/r7s72100-rskrza1.dts
index 8a55a88..2d6968e 100644
--- a/arch/arm/boot/dts/r7s72100-rskrza1.dts
+++ b/arch/arm/boot/dts/r7s72100-rskrza1.dts
@@ -28,7 +28,7 @@
 
 	memory {
 		device_type = "memory";
-		reg = <0x08000000 0x08000000>;
+		reg = <0x08000000 0x02000000>;	/* 32MB @ 0x0x08000000 */
 	};
 
 	lbsc {
diff --git a/arch/arm/configs/rskrza1_xip_defconfig b/arch/arm/configs/rskrza1_xip_defconfig
index 265faf1..4a8f1fb 100644
--- a/arch/arm/configs/rskrza1_xip_defconfig
+++ b/arch/arm/configs/rskrza1_xip_defconfig
@@ -27,6 +27,11 @@ CONFIG_AUTO_ZRELADDR=y
 CONFIG_VFP=y
 CONFIG_NEON=y
 CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IPV6=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
@@ -41,6 +46,8 @@ CONFIG_MTD_M25P80=y
 CONFIG_EEPROM_AT24=y
 CONFIG_SCSI=y
 CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+CONFIG_SH_ETH=y
 CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_MOUSE is not set
 CONFIG_INPUT_TOUCHSCREEN=y
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index c215838..a087ca6 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -49,10 +49,6 @@ config MACH_GENMAI
 	bool "Genmai board"
 	depends on ARCH_R7S72100
 
-config MACH_RSKRZA1
-	bool "RZ/A1 RSK board"
-	depends on ARCH_R7S72100
-
 config MACH_KOELSCH
 	bool "Koelsch board"
 	depends on ARCH_R8A7791
diff --git a/arch/arm/mach-shmobile/board-rskrza1.c b/arch/arm/mach-shmobile/board-rskrza1.c
index 62388d4..0613555 100644
--- a/arch/arm/mach-shmobile/board-rskrza1.c
+++ b/arch/arm/mach-shmobile/board-rskrza1.c
@@ -61,14 +61,29 @@
 #include <media/soc_camera.h>
 #include <media/soc_camera_platform.h>
 #include <media/ov7670.h>
+#include <linux/platform_data/simplefb.h>
 #include <linux/irq.h>
 #include <linux/dma-mapping.h>
 #include <linux/can/platform/rza1_can.h>
+#include <linux/clk.h>
+
+
+/* If an XIP kernel has its memory address set to the begining
+   of internal RAM, we'll assume that external SDRAM is not
+   availible and we should try to reserve RAM when possible */
+#define XIP_KERNEL_WITHOUT_EXTERNAL_RAM (defined(CONFIG_XIP_KERNEL) && (CONFIG_PHYS_OFFSET == 0x20000000))
 
 /* Board Options */
 //#define RSPI_TESTING	/* Uncomment for RSPI4 enabled on CN15 */
 
 
+
+/*
+ * early_usbgs()
+ * - This allows you to select if you want to use
+ *   USB gadget or not.
+ * - Optional: This was just an easy way to switch this for testing
+ */
 static int usbgs = -1;
 static int __init early_usbgs(char *str)
 {
@@ -78,6 +93,11 @@ static int __init early_usbgs(char *str)
 }
 early_param("usbgs", early_usbgs);
 
+/* ==========================================================
+ *			IO Map Section
+ *
+ * Maps physical addresses to virtual addresses
+ * ==========================================================*/
 static struct map_desc rza1_io_desc[] __initdata = {
 	/* create a 1:1 entity map for 0xe8xxxxxx
 	 * used by INTC.
@@ -110,7 +130,12 @@ static struct map_desc rza1_io_desc[] __initdata = {
 #endif
 };
 
-void __init rza1_map_io(void)
+/*
+ * rza1_map_io()
+ * - Called early to set up mappings
+ * - Call twice during boot (before and after MMU setup)
+ */
+void __init r7s72100_map_io(void)
 {
 #ifdef CONFIG_DEBUG_LL
 	/* Note: Becase we defined a .map_io handler, we must manually set our
@@ -121,7 +146,11 @@ void __init rza1_map_io(void)
 }
 
 
-/* DMA */
+/* ==========================================================
+ *			DMA Section
+ *
+ * Defines RZ/A1 DMA channels
+ * ==========================================================*/
 #define CHCFG(reqd_v, loen_v, hien_v, lvl_v, am_v, sds_v, dds_v, tm_v)\
 	{								\
 		.reqd	=	reqd_v,					\
@@ -202,7 +231,7 @@ static const struct rza1_dma_slave_config rza1_dma_slaves[] = {
 static const struct rza1_dma_pdata dma_pdata __initconst = {
 	.slave		= rza1_dma_slaves,
 	.slave_num	= ARRAY_SIZE(rza1_dma_slaves),
-#ifdef CONFIG_XIP_KERNEL
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
 	.channel_num	= 6,	/* Less channels means less RAM (2 for SDHI, 4 for Audio) */
 #else
 	.channel_num	= 16,	/* 16 MAX channels */
@@ -225,8 +254,19 @@ static const struct platform_device_info dma_info  __initconst = {
 	.size_data	= sizeof(dma_pdata),
 };
 
-/* Video */
+/* ==========================================================
+ *			LCD 0 Video Section
+ * Defines VDC5 ch0 LCD controller
+ * Board Specific Portions:
+ * 	- main clock speed
+ * 	- Pin mux setup for Parallel LCD
+ *	- LCD panel description
+ *	- Frame buffer layers
+ * ==========================================================*/
+
+/* BOARD: Change if not using 13.33MHz main crystal */
 #define	P1CLK			((13330000 * 30) / 6)
+/* pixclock is expressed in ps (pico seconds) */
 #define	PIXCLOCK(hz, div)	\
 	(u32)(1000000000000 / ((double)(hz) / (double)(div)))
 
@@ -236,6 +276,7 @@ struct pfc_pinmux_assign {
 	int opts;
 };
 
+/* BOARD: Change if your [LCD0] is on different pins */
 static struct pfc_pinmux_assign lcd0_common[] = {
 	{ P11_15, ALT5, },	/* LCD0_CLK */
 	{ P11_7,  ALT5, },	/* LCD0_DATA0 */
@@ -264,6 +305,8 @@ static struct pfc_pinmux_assign lcd0_common[] = {
 	{ P10_0,  ALT5, },	/* LCD0_DATA23 */
 };
 
+/* BOARD: Change if your [LCD0] is on different pins */
+/* NOTE: Unused TCONS will be left as GPIO */
 static struct pfc_pinmux_assign lcd0_tcon[] = {
 	{ P11_14, ALT5, },	/* LCD0_TCON0 */
 	{ P11_13, ALT5, },	/* LCD0_TCON1 */
@@ -274,59 +317,73 @@ static struct pfc_pinmux_assign lcd0_tcon[] = {
 	{ P11_8,  ALT5, },	/* LCD0_TCON6 */
 };
 
-static void vdc5fb_pinmux(struct pfc_pinmux_assign *pf, size_t num)
-{
-	size_t n;
+/* LCD Frame buffer Declaration
+VDC5_0_BPP:
+	This is the Frame buffer size your application will access (/dev/fb0)
+	Set to either '16' or '32'
+	Note that the color depth of your frame buffer does not have to be the same
+	color depth of your panel. For example, even if you have a full 24-bit LCD panel,
+	you can still set this to 16 or lower.
 
-	for (n = 0; n < num; pf++, n++)
-		r7s72100_pfc_pin_assign(pf->port, pf->mode, DIIO_PBDC_DIS);
-}
+VDC5_0_FBSIZE:
+	Set to the total BYTE size of your frame buffer.
 
-static void vdc5fb_pinmux_tcon(struct pfc_pinmux_assign *pf, size_t num,
-	struct vdc5fb_pdata *pdata)
-{
-	size_t n;
+VDC5_0_FB_ADDR:
+	Set this to the location of your frame buffer in INTERNAL RAM.
+	You can either hard code this address, or set it to 0 and it will
+	be allocated for you during 'probe' (but only if using internal RAM
+	only and your frame buffer is under 1MB).
+*/
 
-	for (n = 0; n < num; pf++, n++)
-		if (pdata->tcon_sel[n] != TCON_SEL_UNUSED)
-			r7s72100_pfc_pin_assign(pf->port, pf->mode, DIIO_PBDC_DIS);
-}
+/* BOARD: Define your [LCD0] frame buffer location and size. */
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
+  #define VDC5_0_BPP 16 /* 16bpp or 32bpp */
+  #define VDC5_0_FBSIZE (800*480*VDC5_0_BPP/8)
+  #define VDC5_0_FB_ADDR 0	/* allcoate at probe */
+#else
+  #define VDC5_0_BPP 32 /* 16bpp or 32bpp */
+  #define VDC5_0_FBSIZE (800*480*VDC5_0_BPP/8)
 
-#ifdef CONFIG_XIP_KERNEL
-#define VDC5_BPP 16 /* 16bpp or 32bpp */
-#define VDC5_FBSIZE (800*480*VDC5_BPP/8)
-/* Let the VDC5 driver carve out the frame buffer out of system memory during boot */
-#define VDC5_FB_ADDR 0	/* allcoate at probe */
+  /* Assume we are using external SDRAM for system memory so we have all
+     the internal memory just for our LCD frame buffer */
+  /* Place at end of internal RAM, but on a PAGE boundry */
+  //#define VDC5_0_FB_ADDR ((0x20A00000 - VDC5_0_FBSIZE) & PAGE_MASK)
 
-#else
-#define VDC5_BPP 32 /* 16bpp or 32bpp */
-#define VDC5_FBSIZE (800*480*VDC5_BPP/8)
-/* Assume we are using external SDRAM for system memory so we have all
-   the internal memory just for our LCD frame buffer */
-/* Place at end of internal RAM, but on a PAGE boundry */
-#define VDC5_FB_ADDR ((0x20A00000 - VDC5_FBSIZE) & PAGE_MASK)
+  /* Fixed allocation */
+  #define VDC5_0_FB_ADDR (0x60000000) /* PAGE 0 (2MB) */
 #endif
 
-/* Sample: Graphics 3 - Image Synthesizer */
-//uint8_t gr3_fb[ 200*200*4 ] __attribute__ ((aligned (PAGE_SIZE)));
-
-static const struct resource vdc5fb_resources[VDC5FB_NUM_RES] __initconst = {
+static const struct resource vdc5fb0_resources[VDC5FB_NUM_RES] __initconst = {
 	[0] = DEFINE_RES_MEM_NAMED(0xfcff6000, 0x00002000, "vdc5fb.0: reg"),
-	[1] = DEFINE_RES_MEM_NAMED(VDC5_FB_ADDR, VDC5_FBSIZE, "vdc5fb.0: fb"),
+	[1] = DEFINE_RES_MEM_NAMED(VDC5_0_FB_ADDR, VDC5_0_FBSIZE, "vdc5fb.0: fb"),
 	[2] = DEFINE_RES_NAMED(75, 23, "vdc5fb.0: irq", IORESOURCE_IRQ),
 };
 
-static int vdc5fb_pinmux_gwp0700cnwv04(struct platform_device *pdev)
+static int vdc5fb_0_pinmux(struct platform_device *pdev)
 {
+	size_t n, total;
+	struct pfc_pinmux_assign *pf;
 	struct vdc5fb_pdata *pdata
 	    = (struct vdc5fb_pdata *)pdev->dev.platform_data;
 
-	vdc5fb_pinmux(lcd0_common, ARRAY_SIZE(lcd0_common));
-	vdc5fb_pinmux_tcon(lcd0_tcon, ARRAY_SIZE(lcd0_tcon), pdata);
+	/* Assign the LCD_0 pins */
+	pf = lcd0_common;
+	total = ARRAY_SIZE(lcd0_common);
+	for (n = 0; n < total; pf++, n++)
+		r7s72100_pfc_pin_assign(pf->port, pf->mode, DIIO_PBDC_DIS);
+
+	/* Assing only the TCON_0 pins that will be used */
+	pf = lcd0_tcon;
+	total = ARRAY_SIZE(lcd0_tcon);
+	for (n = 0; n < total; pf++, n++)
+		if (pdata->tcon_sel[n] != TCON_SEL_UNUSED)
+			r7s72100_pfc_pin_assign(pf->port, pf->mode, DIIO_PBDC_DIS);
 
 	return 0;
 }
 
+/* This structure defines the panel timings */
+/* BOARD: You should rename this strucutre to match your LCD panel */
 static struct fb_videomode videomode_gwp0700cnwv04 = {
 	.name		= "gwp0700cnwv04",
 	.refresh	= 60,
@@ -344,11 +401,24 @@ static struct fb_videomode videomode_gwp0700cnwv04 = {
 	.flag		= 0,
 };
 
+#if 0 /* FLOATING LAYER SAMPLE */
+/* Graphics 3 - Image Synthesizer */
+/* Creates a 200x200 32-bit ARGB floating layer */
+
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
+uint8_t gr3_fb[ 200*200*4 ] __attribute__ ((aligned (PAGE_SIZE)));
+#else
+#define gr3_fb 0x60600000 /* hard coded */
+#endif
+#endif
+
+/* BOARD: You should rename this strucutre to match your LCD panel */
+/* This structure passing info to the VDC5 driver */
 static const struct vdc5fb_pdata vdc5fb_gwp0700cnwv04_pdata = {
 	.name			= "gwp0700cnwv04",
 	.videomode		= &videomode_gwp0700cnwv04,
-	.panel_icksel		= ICKSEL_P1CLK,
-	.bpp			= VDC5_BPP,
+	.panel_icksel		= ICKSEL_P1CLK,	/* see include/video/vdc5fb.h */
+	.bpp			= VDC5_0_BPP,
 	.panel_width		= 154,	/* mm, unused */
 	.panel_height		= 86,	/* mm, unused */
 	.flm_max		= 1,
@@ -363,7 +433,7 @@ static const struct vdc5fb_pdata vdc5fb_gwp0700cnwv04_pdata = {
 		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* LR_INV */
 		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* UD_INV */
 	},
-	.pinmux			= vdc5fb_pinmux_gwp0700cnwv04,
+	.pinmux			= vdc5fb_0_pinmux,
 	.layers			= {
 		/* Graphics 2 - Image Synthesizer */
 		/* Full LCD Panel - will be /dev/fb0 */
@@ -371,18 +441,18 @@ static const struct vdc5fb_pdata vdc5fb_gwp0700cnwv04_pdata = {
 		[2].yres	= 480,
 		[2].x_offset	= 0,
 		[2].y_offset	= 0,
-#if VDC5_BPP == 16
+#if VDC5_0_BPP == 16
 		[2].format	= GR_FORMAT(GR_FORMAT_RGB565) | GR_RDSWA(6),
 #else
 		[2].format	= GR_FORMAT(GR_FORMAT_ARGB8888) | GR_RDSWA(4),
 #endif
-		[2].bpp		= VDC5_BPP,
-		[2].base	= VDC5_FB_ADDR,
+		[2].bpp		= VDC5_0_BPP,
+		[2].base	= VDC5_0_FB_ADDR,
 		[2].blend	 = 0,
 
-#if 0 /* SAMPLE */
+#if 0 /* FLOATING LAYER SAMPLE */
 		/* Graphics 3 - Image Synthesizer */
-		/* Layer 3 - floating layer (Alpha blending) */
+		/* Creates a 200x200 32-bit ARGB floating layer */
 		[3].xres	= 200,
 		[3].yres	= 200,
 		[3].x_offset	= 100,
@@ -395,17 +465,168 @@ static const struct vdc5fb_pdata vdc5fb_gwp0700cnwv04_pdata = {
 	},
 };
 
-static const struct platform_device_info vdc5fb_info __initconst = {
+static const struct platform_device_info vdc5fb0_info __initconst = {
 	.name		= "vdc5fb",
-	.id		= 0,
-	.res		= vdc5fb_resources,
-	.num_res	= ARRAY_SIZE(vdc5fb_resources),
+	.id		= 0,	/* ch 0 */
+	.res		= vdc5fb0_resources,
+	.num_res	= ARRAY_SIZE(vdc5fb0_resources),
 	.data		= &vdc5fb_gwp0700cnwv04_pdata,
 	.size_data	= sizeof(vdc5fb_gwp0700cnwv04_pdata),
 	.dma_mask	= DMA_BIT_MASK(32),	/* only needed if not hardcoding fb */
 };
 
-/* JCU */
+#if 0 /* FLOATING LAYER SAMPLE */
+	/* Graphics 3 - Image Synthesizer */
+	/* Map our floating layer as /dev/fb1 */
+  #ifndef CONFIG_FB_SIMPLE
+    #error Requires CONFIG_FB_SIMPLE=y
+  #endif
+
+/* simple-framebuffer */
+static const struct resource simplefb_resources[] __initconst = {
+	DEFINE_RES_MEM_NAMED(gr3_fb, 200*200*4, "vdc5_alpha.0: fb"),
+};
+static const struct simplefb_platform_data simplefb_pdata = {
+	.width = 200,
+	.height = 200,
+	.stride = 200 * 4,
+	.format = "a8r8g8b8",
+};
+static const struct platform_device_info simplefb_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "simple-framebuffer",
+	.id		= -1,
+	.res		= simplefb_resources,
+	.num_res	= ARRAY_SIZE(simplefb_resources),
+	.data		= &simplefb_pdata,
+	.size_data	= sizeof(simplefb_pdata),
+};
+#endif /* FLOATING LAYER SAMPLE */
+
+/* Example of using LVDS on VDC5 ch 1 */
+//#define USE_LVDS
+#ifdef USE_LVDS
+/* ==========================================================
+ *			LCD 1 Video Section
+ * Defines VDC5 ch1 LCD controller (RZ/A1M and RZ/A1H only)
+ * Board Specific Portions:
+ *	- Assumes LVDS
+ * 	- main clock speed
+ * 	- Pin mux setup for Parallel LCD
+ *	- LCD panel description
+ *	- Frame buffer layers
+ * ==========================================================*/
+
+/* LCD 1 Frame buffer Declaration */
+/* BOARD: Define your [LCD1 LVDS] frame buffer location and size.
+VDC5_1_BPP, VDC5_1_FBSIZE, VDC5_1_FB_ADDR:
+	See VDC5_1_XXX for more info
+*/
+/* NOTE: If you want to use VDC5 ch0 and ch1 at the same time, you
+   need to put their frame buffers in different RAM Pages */
+#define VDC5_1_BPP 16
+#define VDC5_1_FBSIZE (1280*800*VDC5_1_BPP/8)
+#define VDC5_1_FB_ADDR (0x60200000) /* PAGE 2 (2MB) */
+static const struct resource vdc5fb1_resources[VDC5FB_NUM_RES] __initconst = {
+	[0] = DEFINE_RES_MEM_NAMED(0xfcff8000, 0x00002000, "vdc5fb.1: reg"),
+	[1] = DEFINE_RES_MEM_NAMED(VDC5_1_FB_ADDR, VDC5_1_FBSIZE, "vdc5fb.1: fb"),
+	[2] = DEFINE_RES_NAMED(99, 23, "vdc5fb.1: irq", IORESOURCE_IRQ),
+};
+
+static int vdc5fb_pinmux_lvds(struct platform_device *pdev)
+{
+	/* When using the LVDS pins, PIPCn.PIPCnm bits should be Set to 0
+	   and the port direction should be set as input. See Table 54.7 */
+	r7s72100_pfc_pin_assign(P5_0, ALT1, DIR_IN); /* TXCLKOUTP */
+	r7s72100_pfc_pin_assign(P5_1, ALT1, DIR_IN); /* TXCLKOUTM */
+	r7s72100_pfc_pin_assign(P5_2, ALT1, DIR_IN); /* TXOUT2P */
+	r7s72100_pfc_pin_assign(P5_3, ALT1, DIR_IN); /* TXOUT2M */
+	r7s72100_pfc_pin_assign(P5_4, ALT1, DIR_IN); /* TXOUT1P */
+	r7s72100_pfc_pin_assign(P5_5, ALT1, DIR_IN); /* TXOUT1M */
+	r7s72100_pfc_pin_assign(P5_6, ALT1, DIR_IN); /* TXOUT0P */
+	r7s72100_pfc_pin_assign(P5_7, ALT1, DIR_IN); /* TXOUT0M */
+
+	return 0;
+}
+
+static int vdc5fb_1_pinmux(struct platform_device *pdev)
+{
+	vdc5fb_pinmux_lvds( pdev );
+	return 0;
+}
+
+/* LVDS Panel: HSD070PWW1 -B01 | 1280x800 (WXVGA), 7", LVDS, 16bpp */
+
+static struct fb_videomode videomode_hsd070pww1 = {
+	.name		= "HSD070PWW1",
+	.refresh	= 60,	/* not fixed */
+	.xres		= 1280,
+	.yres		= 800,
+	.pixclock	= PIXCLOCK(71100000,1),  /* min:64.3MHz, typ:71.1MHz, max:82MHz */
+	.left_margin	= 16,	/* horizontal back porch */
+	.right_margin	= 16,	/* horizontal front porch */
+	.upper_margin	= 24,	/* vertical back porch */
+	.lower_margin	= 1,	/* vertical front porch */
+	.hsync_len	= 136,	/* Horizontal Blanking Time */
+	.vsync_len	= 3,	/* Vertical Blanking Time */
+	.sync		= FB_SYNC_HOR_HIGH_ACT, /*Polarity Inversion Control of STH Signal*/
+	.vmode		= 0,
+	.flag		= 0,
+};
+
+static const struct vdc5fb_pdata vdc5fb_hsd070pww1_pdata = {
+	.name			= "hsd070pww1",
+	.videomode		= &videomode_hsd070pww1,
+	.panel_ocksel		= OCKSEL_PLL_DIV7,	/* see include/video/vdc5fb.h */
+	.bpp			= VDC5_1_BPP,
+	.panel_width		= 0,	/* mm, unused */
+	.panel_height		= 0,	/* mm, unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB888,
+	.use_lvds		= 1,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_UNUSED,	/* VSYNC (for LVDS, VS must be TCON0) */
+		[LCD_TCON1]	= TCON_SEL_UNUSED,	/* (not connected to LVDS circuit) */
+		[LCD_TCON2]	= TCON_SEL_UNUSED,	/* HSYNC (for LVDS, HS must be TCON2) */
+		[LCD_TCON3]	= TCON_SEL_DE,		/* DE (for LVDS, DE must be TCON3) */
+		[LCD_TCON4]	= TCON_SEL_UNUSED,	/* (not connected to LVDS circuit) */
+		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* (not connected to LVDS circuit) */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* (not connected to LVDS circuit) */
+	},
+	.pinmux			= vdc5fb_1_pinmux,
+	.layers			= {
+		/* Graphics 2 - Image Synthesizer */
+		/* Full LCD Panel - will be /dev/fb0 */
+		[2].xres	= 1280,
+		[2].yres	= 800,
+		[2].x_offset	= 0,
+		[2].y_offset	= 0,
+#if VDC5_1_BPP == 16
+		[2].format	= GR_FORMAT(GR_FORMAT_RGB565) | GR_RDSWA(6),
+#else
+		[2].format	= GR_FORMAT(GR_FORMAT_ARGB8888) | GR_RDSWA(4),
+#endif
+		[2].bpp		= VDC5_1_BPP,
+		[2].base	= VDC5_1_FB_ADDR,
+		[2].blend	 = 0,
+	},
+};
+
+static const struct platform_device_info vdc5fb1_info __initconst = {
+	.name		= "vdc5fb",
+	.id		= 1,	/* ch 1 */
+	.res		= vdc5fb1_resources,
+	.num_res	= ARRAY_SIZE(vdc5fb1_resources),
+	.data		= &vdc5fb_hsd070pww1_pdata,
+	.size_data	= sizeof(vdc5fb_hsd070pww1_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),	/* only needed if not hardcoding fb */
+};
+
+#endif /* USE_LVDS */
+
+/* ==========================================================
+ *			JCU Section
+ * ==========================================================*/
 static const struct uio_info jcu_platform_pdata __initconst = {
 	.name = "JCU",
 	.version = "0",
@@ -415,7 +636,7 @@ static const struct uio_info jcu_platform_pdata __initconst = {
 static const struct resource jcu_resources[] __initconst = {
 	DEFINE_RES_MEM_NAMED(0xe8017000, 0x1000, "jcu:reg"), /* for JCU of RZ */
 	DEFINE_RES_MEM_NAMED(0xfcfe0000, 0x2000, "jcu:rstreg clkreg"), /* Use STBCR6 & SWRSTCR2 */
-	DEFINE_RES_MEM_NAMED(0x20200000, 0x100000, "jcu:iram"), /* (Non cacheable 1MB) */
+	DEFINE_RES_MEM_NAMED(0x60800000, 0x100000, "jcu:iram"), /* (Non cacheable 1MB) */
 };
 
 static const struct platform_device_info jcu_info __initconst = {
@@ -427,7 +648,9 @@ static const struct platform_device_info jcu_info __initconst = {
 	.num_res	= ARRAY_SIZE(jcu_resources),
 };
 
-/* Ether */
+/* ==========================================================
+ *                Ethernet Section
+ * ==========================================================*/
 static const struct sh_eth_plat_data ether_pdata __initconst = {
 	.phy			= 0x00, /* PD60610 */
 	.edmac_endian		= EDMAC_LITTLE_ENDIAN,
@@ -452,6 +675,9 @@ static const struct platform_device_info ether_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
+/* ==========================================================
+ *                     I2C Section
+ * ==========================================================*/
 /* I2C0*/
 static const struct resource riic0_resources[] __initconst = {
 	DEFINE_RES_MEM(0xfcfee000, 0x400),
@@ -562,16 +788,18 @@ static const struct platform_device_info riic3_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
+/* ==========================================================
+ *		I2C Device Section
+ *
+ * Define devices that reside on I2C busses that
+ * need to be discovered
+ * ==========================================================*/
+
+/* BOARD: This is the Capacitive touchscreen controller that
+	  is on the RSK board */
 static struct edt_ft5x06_platform_data ft5216_pdata __initdata = {
 	.irq_pin	= -1,
 	.reset_pin	= -1,
-
-	/* startup defaults for operational parameters */
-//	bool use_parameters;
-//	u8 gain;
-//	u8 threshold;
-//	u8 offset;
-//	u8 report_rate;
 };
 
 
@@ -583,14 +811,6 @@ static const struct i2c_board_info i2c0_devices[] __initconst = {
 	},
 };
 
-/* Init TC_IRQ1 as input */
-static void __init gpio_irq_init(void) {
-	/* Set for low edge trigger */
-	void __iomem *irc1 = IOMEM(0xfcfef802);
-	__raw_writew((__raw_readw(irc1) & ~(0x3 << 2)), irc1);
-	r7s72100_pfc_pin_assign(P4_9, ALT8, DIIO_PBDC_DIS);  /* IRQ1 */
-}
-
 static struct at24_platform_data eeprom_pdata = {
 	.byte_len = 2048,
 	.page_size = 16,
@@ -606,7 +826,13 @@ static const struct i2c_board_info i2c3_devices[] __initconst = {
 	},
 };
 
-/* OSTM */
+/* ==========================================================
+ *			OS Timer Section
+ *
+ * High precision OS Timer
+ * When using this timer as a system time, you can get better
+ * accuracy then the default MTU2 timer.
+ * ==========================================================*/
 static struct rza1_ostm_pdata ostm_pdata = {
 	.clksrc.name = "ostm.0",
 	.clksrc.rating = 300,
@@ -630,7 +856,9 @@ static const struct platform_device_info ostm_info __initconst = {
 	.num_res	= ARRAY_SIZE(ostm_resources),
 };
 
-/* RTC */
+/* ==========================================================
+ *			RTC Section
+ * ==========================================================*/
 static const struct resource rtc_resources[] __initconst = {
 	DEFINE_RES_MEM(0xfcff1000, 0x2e),
 	DEFINE_RES_IRQ(gic_iid(309)),	/* Period IRQ */
@@ -647,7 +875,10 @@ static const struct platform_device_info rtc_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
-/* NOR Flash */
+/* ==========================================================
+ *		Parallel NOR Flash Section
+ * ==========================================================*/
+/* BOARD: You can define the partitions however you want */
 static struct mtd_partition nor_flash_partitions[] __initdata = {
 	{
 		.name		= "nor_u-boot",
@@ -698,8 +929,89 @@ static const struct platform_device_info nor_flash_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
-/* SPI NOR Flash */
-/* Single Flash only */
+/* ==========================================================
+ *		RSPI Section
+ *
+ * Standard SPI controller
+ * ==========================================================*/
+#define RSPI_RESOURCE(idx, baseaddr, irq)				\
+static const struct resource rspi##idx##_resources[] __initconst = {	\
+	DEFINE_RES_MEM(baseaddr, 0x24),					\
+	DEFINE_RES_IRQ_NAMED(irq, "error"),				\
+	DEFINE_RES_IRQ_NAMED(irq + 1, "rx"),				\
+	DEFINE_RES_IRQ_NAMED(irq + 2, "tx"),				\
+}
+
+RSPI_RESOURCE(0, 0xe800c800, gic_iid(270));
+RSPI_RESOURCE(1, 0xe800d000, gic_iid(273));
+RSPI_RESOURCE(2, 0xe800d800, gic_iid(276));
+RSPI_RESOURCE(3, 0xe800e000, gic_iid(279));
+RSPI_RESOURCE(4, 0xe800e800, gic_iid(282));
+
+static const struct rspi_plat_data rspi_pdata __initconst = {
+	.num_chipselect	= 1,
+};
+
+#define r7s72100_register_rspi(idx)					   \
+	platform_device_register_resndata(&platform_bus, "rspi-rz", idx,   \
+					rspi##idx##_resources,		   \
+					ARRAY_SIZE(rspi##idx##_resources), \
+					&rspi_pdata, sizeof(rspi_pdata))
+
+/* ==========================================================
+ *		QSPI Flash Controller Section
+ *
+ * SPI Multi I/O
+ * Supports Single SPI flash only
+ * "SPIBSC" = SPI Bus State Controller
+ * ==========================================================*/
+/* SPIBSC0 */
+static const struct sh_spibsc_info spibsc0_pdata = {
+	.bus_num	= 5,
+};
+
+static const struct resource spibsc0_resources[] __initconst = {
+	DEFINE_RES_MEM(0x3fefa000, 0x100),
+};
+
+static const struct platform_device_info spibsc0_info __initconst = {
+	.name		= "spibsc",
+	.id		= 0,
+	.data 		= &spibsc0_pdata,
+	.size_data	= sizeof(spibsc0_pdata),
+	.num_res	= ARRAY_SIZE(spibsc0_resources),
+	.res		= spibsc0_resources,
+};
+
+/* SPIBSC1 */
+static const struct sh_spibsc_info spibsc1_pdata = {
+	.bus_num	= 6,
+};
+
+static const struct resource spibsc1_resources[] __initconst = {
+	DEFINE_RES_MEM(0x3fefb000, 0x100),
+};
+
+static const struct platform_device_info spibsc1_info __initconst = {
+	.name		= "spibsc",
+	.id		= 1,
+	.data 		= &spibsc1_pdata,
+	.size_data	= sizeof(spibsc1_pdata),
+	.num_res	= ARRAY_SIZE(spibsc1_resources),
+	.res		= spibsc1_resources,
+};
+
+/* ==========================================================
+ *		External SPI Flash Device Section
+ *
+ * Register the external SPI flash devices
+ * Define the partitions of the flash devices
+ * ==========================================================*/
+/* BOARD: This structure is to define what external SPI Flash device
+	  you have connected */
+
+/* BOARD: You can define the partitions however you want */
+/* Spansion flash on SPIBSC0 */
 static struct mtd_partition spibsc0_flash_partitions[] = {
 	{
 		.name		= "spibsc0_loader",
@@ -709,21 +1021,34 @@ static struct mtd_partition spibsc0_flash_partitions[] = {
 	},
 	{
 		.name		= "spibsc0_bootenv",
-		.offset		= MTDPART_OFS_APPEND,
+		.offset		= 0x00080000,
+		.size		= 0x00040000,
+	},
+	{
+		.name		= "spibsc0_dtbs",
+		.offset		= 0x000C0000,
 		.size		= 0x00040000,
 	},
 	{
 		.name		= "spibsc0_kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 0x00400000,
+		.offset		= 0x00100000,
+		.size		= 0x00700000,
 	},
 	{
 		.name		= "spibsc0_rootfs",
-		.offset		= MTDPART_OFS_APPEND,
+		.offset		= 0x00800000,
 		.size		= MTDPART_SIZ_FULL,
 	},
 };
+static struct flash_platform_data spibsc0_flash_pdata = {
+	.name	= "m25p80",
+	.parts	= spibsc0_flash_partitions,
+	.nr_parts = ARRAY_SIZE(spibsc0_flash_partitions),
+	.type = "s25fl512s",
+};
 
+#if 0 /* Just for example, not populated on RSK */
+/* Dummy flash on SPIBSC1 */
 static struct mtd_partition spibsc1_flash_partitions[] = {
 	{
 		.name		= "spibsc1_data",
@@ -731,23 +1056,61 @@ static struct mtd_partition spibsc1_flash_partitions[] = {
 		.size		= MTDPART_SIZ_FULL,
 	},
 };
-
-static struct flash_platform_data spibsc0_flash_pdata = {
-	.name	= "m25p80",
-	.parts	= spibsc0_flash_partitions,
-	.nr_parts = ARRAY_SIZE(spibsc0_flash_partitions),
-	.type = "s25fl512s",
-};
-
 static struct flash_platform_data spibsc1_flash_pdata = {
 	.name	= "m25p80",
 	.parts	= spibsc1_flash_partitions,
 	.nr_parts = ARRAY_SIZE(spibsc1_flash_partitions),
 	.type = "s25fl512s",
 };
+#endif
+
+/* Group the SPI flash devices so they can be reigstered */
+static struct spi_board_info rskrza1_spi_devices[] __initdata = {
+#if defined(RSPI_TESTING)
+	{
+		/* spidev */
+		.modalias		= "spidev",
+		.max_speed_hz           = 5000000,
+		.bus_num                = 4,
+		.chip_select            = 0,
+		.mode			= SPI_MODE_3,
+	},
+#endif
+	{
+		/* SPI Flash0 */
+		.modalias = "m25p80",
+		.bus_num = 5,
+		.chip_select = 0,
+		.platform_data = &spibsc0_flash_pdata,
+	},
+#if 0 /* Just for example */
+	{
+		/* SPI Flash1 */
+		.modalias = "m25p80",
+		.bus_num = 6,
+		.chip_select = 0,
+		.platform_data = &spibsc1_flash_pdata,
+	},
+#endif
+};
+
 
-/* QSPI Flash (Memory Map Mode, read only) */
-/* Dual Flash */
+
+/* ==========================================================
+ *		MTD ROM Section
+ *		(Memory mapped QSPI)
+ *
+ * This assume u-boot has already memory mapped the QSPI
+ * Flash in XIP mode. This a generic kernel driver to map
+ * that linear physical memory space to a MTD device so
+ * you can mount a root file system.
+ *
+ * Memory space is read only.
+ * ==========================================================*/
+
+/* BOARD: Since the QSPI memory mapping starts at 0x18000000,
+          this mapping for a rootfs image at 0x18800000 (as in
+	  a 0x00800000 offset). */
 static struct mtd_partition qspi_flash_partitions[] __initdata = {
 	{
 		.name		= "qspi_rootfs",
@@ -778,9 +1141,56 @@ static const struct platform_device_info qspi_flash_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
-/* PWM Pin (Pin TIOC4A only) */
-/* RSKRZA1 does not have TIOC4A attached to anything */
-#if 0
+/* ==========================================================
+ *		SCIF Section
+ * UART
+ * ==========================================================*/
+#define R7S72100_SCIF(index, baseaddr, irq)				\
+static const struct plat_sci_port scif##index##_platform_data = {	\
+	.type		= PORT_SCIF,					\
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,		\
+	.flags		= UPF_BOOT_AUTOCONF | UPF_IOREMAP,		\
+	.capabilities	= SCIx_HAVE_RTSCTS,				\
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |	\
+			  SCSCR_REIE,					\
+};									\
+									\
+static struct resource scif##index##_resources[] = {			\
+	DEFINE_RES_MEM(baseaddr, 0x100),				\
+	DEFINE_RES_IRQ(irq + 1),					\
+	DEFINE_RES_IRQ(irq + 2),					\
+	DEFINE_RES_IRQ(irq + 3),					\
+	DEFINE_RES_IRQ(irq),						\
+}									\
+
+/* BOARD: To save on RAM usage, we are only declaring the SCIF
+	  channels we plan on using. Modify if you plan on
+	  using other channels */
+//R7S72100_SCIF(0, 0xe8007000, gic_iid(221));	/* Not used */
+//R7S72100_SCIF(1, 0xe8007800, gic_iid(225));	/* Not used */
+R7S72100_SCIF(2, 0xe8008000, gic_iid(229));
+//R7S72100_SCIF(3, 0xe8008800, gic_iid(233));	/* Not used */
+//R7S72100_SCIF(4, 0xe8009000, gic_iid(237));	/* Not used */
+//R7S72100_SCIF(5, 0xe8009800, gic_iid(241));	/* Not used */
+//R7S72100_SCIF(6, 0xe800a000, gic_iid(245));	/* Not used */
+//R7S72100_SCIF(7, 0xe800a800, gic_iid(249));	/* Not used */
+
+#define r7s72100_register_scif(index)					       \
+	platform_device_register_resndata(&platform_bus, "sh-sci", index,      \
+					  scif##index##_resources,	       \
+					  ARRAY_SIZE(scif##index##_resources), \
+					  &scif##index##_platform_data,	       \
+					  sizeof(scif##index##_platform_data))
+
+/* ==========================================================
+ *		PWM/LCD Backlight Section
+ *
+ * This is just a driver example for PWM Pin (Pin TIOC4A only)
+ * RSKRZA1 does not have TIOC4A attached to anything.
+ * This PWM driver was intended to be used as a variable LCD
+ * backlight driver. It was devleoped on a different RZ/A1 board.
+ * ==========================================================*/
+#if 0 /* Just as an example */
 static const struct resource pwm_resources[] __initconst = {
 	DEFINE_RES_MEM(0xfcff0200, 0x4c),	/* mtu2_3,4 */
 	DEFINE_RES_MEM(0xfcff0280, 0x6),	/* mtu2 share regs */
@@ -795,7 +1205,7 @@ static const struct platform_device_info pwm0_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
-/* Backlight */
+/* Backlight Registration */
 static struct platform_pwm_backlight_data pwm_backlight_pdata = {
 	.max_brightness = 255,
 	.dft_brightness = 255,
@@ -814,103 +1224,21 @@ static const struct platform_device_info pwm_backlight_info __initconst = {
 };
 #endif
 
-/* RSPI */
-#define RSPI_RESOURCE(idx, baseaddr, irq)				\
-static const struct resource rspi##idx##_resources[] __initconst = {	\
-	DEFINE_RES_MEM(baseaddr, 0x24),					\
-	DEFINE_RES_IRQ_NAMED(irq, "error"),				\
-	DEFINE_RES_IRQ_NAMED(irq + 1, "rx"),				\
-	DEFINE_RES_IRQ_NAMED(irq + 2, "tx"),				\
-}
-
-RSPI_RESOURCE(0, 0xe800c800, gic_iid(270));
-RSPI_RESOURCE(1, 0xe800d000, gic_iid(273));
-RSPI_RESOURCE(2, 0xe800d800, gic_iid(276));
-RSPI_RESOURCE(3, 0xe800e000, gic_iid(279));
-RSPI_RESOURCE(4, 0xe800e800, gic_iid(282));
-
-static const struct rspi_plat_data rspi_pdata __initconst = {
-	.num_chipselect	= 1,
-};
-
-#define r7s72100_register_rspi(idx)					   \
-	platform_device_register_resndata(&platform_bus, "rspi-rz", idx,   \
-					rspi##idx##_resources,		   \
-					ARRAY_SIZE(rspi##idx##_resources), \
-					&rspi_pdata, sizeof(rspi_pdata))
-
-
-static struct spi_board_info rskrza1_spi_devices[] __initdata = {
-#if defined(RSPI_TESTING)
-	{
-		/* spidev */
-		.modalias		= "spidev",
-		.max_speed_hz           = 5000000,
-		.bus_num                = 4,
-		.chip_select            = 0,
-		.mode			= SPI_MODE_3,
-	},
-#endif
-	{
-		/* SPI Flash0 */
-		.modalias = "m25p80",
-		.bus_num = 5,
-		.chip_select = 0,
-		.platform_data = &spibsc0_flash_pdata,
-	},
-	{
-		/* SPI Flash1 */
-		.modalias = "m25p80",
-		.bus_num = 6,
-		.chip_select = 0,
-		.platform_data = &spibsc1_flash_pdata,
-	},
-};
-
-/* spibsc0 */
-static const struct sh_spibsc_info spibsc0_pdata = {
-	.bus_num	= 5,
-};
-
-static const struct resource spibsc0_resources[] __initconst = {
-	DEFINE_RES_MEM(0x3fefa000, 0x100),
-};
-
-static const struct platform_device_info spibsc0_info __initconst = {
-	.name		= "spibsc",
-	.id		= 0,
-	.data 		= &spibsc0_pdata,
-	.size_data	= sizeof(spibsc0_pdata),
-	.num_res	= ARRAY_SIZE(spibsc0_resources),
-	.res		= spibsc0_resources,
-};
-
-/* spibsc1 */
-static const struct sh_spibsc_info spibsc1_pdata = {
-	.bus_num	= 6,
-};
-
-static const struct resource spibsc1_resources[] __initconst = {
-	DEFINE_RES_MEM(0x3fefb000, 0x100),
-};
-
-static const struct platform_device_info spibsc1_info __initconst = {
-	.name		= "spibsc",
-	.id		= 1,
-	.data 		= &spibsc1_pdata,
-	.size_data	= sizeof(spibsc1_pdata),
-	.num_res	= ARRAY_SIZE(spibsc1_resources),
-	.res		= spibsc1_resources,
-};
-
-/* ADC */
-static const struct resource adc0_resources[] __initconst = {
-	DEFINE_RES_MEM(0xe8005800, 0x100),
-	DEFINE_RES_MEM(0xfcff0280, 0x6),
-	DEFINE_RES_MEM(0xfcff0380, 0x21),
-	DEFINE_RES_IRQ(gic_iid(170)),
-	DEFINE_RES_IRQ(gic_iid(171)),
-	DEFINE_RES_IRQ(gic_iid(146)),
+/* ==========================================================
+ *		ADC Section
+ *
+ * This is just a driver example for PWM Pin (Pin TIOC4A only)
+ * RSKRZA1 does not have TIOC4A attached to anything.
+ * This PWM driver was intended to be used as a variable LCD
+ * backlight driver. It was devleoped on a different RZ/A1 board.
+ * ==========================================================*/
+static const struct resource adc0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8005800, 0x100),
+	DEFINE_RES_MEM(0xfcff0280, 0x6),
+	DEFINE_RES_MEM(0xfcff0380, 0x21),
+	DEFINE_RES_IRQ(gic_iid(170)),
+	DEFINE_RES_IRQ(gic_iid(171)),
+	DEFINE_RES_IRQ(gic_iid(146)),
 };
 
 static const struct sh_adc_data adc0_pdata __initconst = {
@@ -928,7 +1256,11 @@ static const struct platform_device_info adc0_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
-/* MMCIF */
+/* ==========================================================
+ *		MMC Section
+ *
+ * Same for MMC Card or eMMC chip
+ * ==========================================================*/
 static const struct resource sh_mmcif_resources[] __initconst = {
 	DEFINE_RES_MEM_NAMED(0xe804c800, 0x100, "MMCIF"),
 	DEFINE_RES_IRQ(gic_iid(300)),
@@ -953,6 +1285,11 @@ static const struct platform_device_info mmc_info __initconst = {
 	.size_data	= sizeof(sh_mmcif_pdata),
 };
 
+/* ==========================================================
+ *		SD Card Section
+ *
+ * SD Host Interface
+ * ==========================================================*/
 /* SDHI0 */
 static struct sh_mobile_sdhi_info sdhi0_pdata = {
 	.dma_slave_tx	= RZA1DMA_SLAVE_SDHI0_TX,
@@ -1005,7 +1342,9 @@ static const struct platform_device_info sdhi1_info __initconst = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
-/* USB Host */
+/* ==========================================================
+ *		USB Host Section
+ * ==========================================================*/
 static const struct r8a66597_platdata r8a66597_pdata __initconst = {
 	.endian = 0,
 	.on_chip = 1,
@@ -1040,7 +1379,9 @@ static const struct platform_device_info r8a66597_usb_host1_info __initconst = {
 	.num_res	= ARRAY_SIZE(r8a66597_usb_host1_resources),
 };
 
-/* USB Gadget */
+/* ==========================================================
+ *		USB Device (Gadget) Section
+ * ==========================================================*/
 static const struct r8a66597_platdata r8a66597_usb_gadget0_pdata __initconst = {
 	.endian = 0,
 	.on_chip = 1,
@@ -1081,6 +1422,9 @@ static const struct platform_device_info r8a66597_usb_gadget1_info __initconst =
 	.num_res	= ARRAY_SIZE(r8a66597_usb_gadget1_resources),
 };
 
+/* ==========================================================
+ *		CAN Bus Section
+ * ==========================================================*/
 #ifdef CONFIG_CAN_RZA1
 static struct resource rz_can_resources[] = {
 	[0] = {
@@ -1125,67 +1469,9 @@ static struct platform_device_info rz_can_device = {
 };
 #endif /* CONFIG_CAN_RZA1 */
 
-/* Write to I2C device */
-/* stolen from board-sx1.c */
-int rza1_i2c_write_byte(u8 ch, u8 devaddr, u8 regoffset, u8 value)
-{
-	struct i2c_adapter *adap;
-	int err;
-	struct i2c_msg msg[1];
-	unsigned char data[2];
-
-	adap = i2c_get_adapter(ch);
-	if (!adap)
-		return -ENODEV;
-	msg->addr = devaddr;	/* I2C address of chip */
-	msg->flags = 0;
-	msg->len = 2;
-	msg->buf = data;
-	data[0] = regoffset;	/* register num */
-	data[1] = value;		/* register data */
-	err = i2c_transfer(adap, msg, 1);
-	i2c_put_adapter(adap);
-	if (err >= 0)
-		return 0;
-	return err;
-}
-
-/* Read from I2C device */
-/* stolen from board-sx1.c */
-int rza1_i2c_read_byte(u8 ch, u8 devaddr, u8 regoffset, u8 *value)
-{
-	struct i2c_adapter *adap;
-	int err;
-	struct i2c_msg msg[1];
-	unsigned char data[2];
-
-	adap = i2c_get_adapter(ch);
-	if (!adap)
-		return -ENODEV;
-
-	msg->addr = devaddr;	/* I2C address of chip */
-	msg->flags = 0;
-	msg->len = 1;
-	msg->buf = data;
-	data[0] = regoffset;	/* register num */
-	err = i2c_transfer(adap, msg, 1);
-	if (err < 0)
-		return err;
-
-	msg->addr = devaddr;	/* I2C address */
-	msg->flags = I2C_M_RD;
-	msg->len = 1;
-	msg->buf = data;
-	err = i2c_transfer(adap, msg, 1);
-	*value = data[0];
-	i2c_put_adapter(adap);
-
-	if (err >= 0)
-		return 0;
-	return err;
-}
-
-/* Audio */
+/* ==========================================================
+ *		Audio Section
+ * ==========================================================*/
 static const struct platform_device_info alsa_soc_info = {
 	.name		= "rskrza1_alsa_soc_platform",
 	.id		= 0,
@@ -1281,6 +1567,127 @@ static const struct platform_device_info scux_info __initconst = {
 	.res		= scux_resources,
 };
 
+/* ==========================================================
+ *		OV7670 Section
+ *
+ * OV7670 Camera Example
+ * ==========================================================*/
+/* BOARD: This was only for example. If you are not using a
+	  OV7670, you can remove this seciton */
+static struct ov7670_config ov7670_config = {
+	.min_width =		320,	/* Filter out smaller sizes */
+	.min_height =		160,	/* Filter out smaller sizes */
+	.clock_speed =		0,	/* External clock speed (MHz) */
+	.use_smbus =		0,	/* Use smbus I/O instead of I2C */
+	.pll_bypass =		0,	/* Choose whether to bypass the PLL */
+	.pclk_hb_disable =	0,	/* Disable toggling pixclk during horizontal blanking */
+};
+
+static struct i2c_board_info ceu_camera = {
+	I2C_BOARD_INFO("ov7670", 0x21),
+};
+
+static struct soc_camera_link ceu_iclink = {
+	.bus_id = 0,
+	.board_info = &ceu_camera,
+	.i2c_adapter_id = 0,
+	.priv = &ov7670_config,
+};
+
+static const struct platform_device_info ceu_camera_info __initconst = {
+	.name = "soc-camera-pdrv",
+	.id = 0,
+	.data = &ceu_iclink,
+	.size_data = sizeof(ceu_iclink),
+};
+
+/* ==========================================================
+ *		CEU Section
+ *
+ * Camera Engine Unit
+ * ==========================================================*/
+static struct sh_mobile_ceu_info sh_mobile_ceu_info = {
+	.flags = SH_CEU_FLAG_USE_8BIT_BUS,
+	.max_width = 1280,
+	.max_height = 768,
+};
+
+static struct resource ceu_resources[] = {
+	[0] = {
+		.name	= "CEU",
+		.start	= 0xE8210000,
+		.end	= 0xE821000f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = gic_iid(364),
+		.flags  = IORESOURCE_IRQ,
+	},
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
+	/* CEU Requires dedicated memory when in XIP mode, as there's not enough contiguous
+	 * memory for the buffers. You must also specify mem=8M on the kernel command line */
+	[2] = {
+		.name	= "CEU Buffer",
+		.start	= 0x20800000,
+		.end	= 0x20A00000,
+		.flags	= IORESOURCE_MEM,
+	},
+#endif
+};
+
+static const struct platform_device_info ceu_info __initconst = {
+	.name		= "sh_mobile_ceu",
+	.id		= 0,
+	.res		= ceu_resources,
+	.num_res	= ARRAY_SIZE(ceu_resources),
+	.data		= &sh_mobile_ceu_info,
+	.size_data	= sizeof(sh_mobile_ceu_info),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+#ifdef CONFIG_VIDEO_SH_MOBILE_CEU
+static struct pfc_pinmux_assign ceu_common[] = {
+	{ P11_11, ALT1, },	/* VIO_D23 */
+	{ P11_10, ALT1, },	/* VIO_D22 */
+	{ P11_9,  ALT1, },	/* VIO_D21 */
+	{ P11_8,  ALT1, },	/* VIO_D20 */
+	{ P11_7,  ALT1, },	/* VIO_D19 */
+	{ P11_6,  ALT1, },	/* VIO_D18 */
+	{ P11_5,  ALT1, },	/* VIO_D17 */
+	{ P11_4,  ALT1, },	/* VIO_D16 */
+	{ P11_3,  ALT6, },	/* VIO_D15 */
+	{ P11_2,  ALT6, },	/* VIO_D14 */
+	{ P11_1,  ALT6, },	/* VIO_D13 */
+	{ P11_0,  ALT6, },	/* VIO_D12 */
+	{ P10_15, ALT6, },	/* VIO_D11 */
+	{ P10_14, ALT6, },	/* VIO_D10 */
+	{ P10_13, ALT6, },	/* VIO_D9 */
+	{ P10_12, ALT6, },	/* VIO_D8 */
+	{ P10_11, ALT6, },	/* VIO_D7 */
+	{ P10_10, ALT6, },	/* VIO_D6 */
+	{ P10_9,  ALT6, },	/* VIO_D5 */
+	{ P10_8,  ALT6, },	/* VIO_D4 */
+	{ P10_7,  ALT6, },	/* VIO_D3 */
+	{ P10_6,  ALT6, },	/* VIO_D2 */
+	{ P10_5,  ALT6, },	/* VIO_D1 */
+	{ P10_4,  ALT6, },	/* VIO_D0 */
+	{ P10_3,  ALT6, },	/* VIO_DFLD */
+	{ P10_2,  ALT6, },	/* VIO_DHD */
+	{ P10_1,  ALT6, },	/* VIO_DVD */
+	{ P10_0,  ALT6, },	/* VIO_CLK */
+};
+
+static void ceu_pinmux(void)
+{
+	size_t n;
+
+	for (n = 0; n < ARRAY_SIZE(ceu_common); n++)
+		r7s72100_pfc_pin_assign(ceu_common[n].port, ceu_common[n].mode, DIIO_PBDC_EN);
+}
+#endif
+
+
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
 /* By default, the Linux ARM code will pre-allocated IRQ descriptors
    based on the size (HW) of the GIC. For this device, that means
    576 possible interrutps sources. This eats up a lot of RAM at
@@ -1379,148 +1786,69 @@ static void remove_irqs(void)
 			irq_free_descs(i, 1);		/* un-used irq */
 	}
 }
+#endif /* XIP_KERNEL_WITHOUT_EXTERNAL_RAM */
 
-/* SCIF */
-#define R7S72100_SCIF(index, baseaddr, irq)				\
-static const struct plat_sci_port scif##index##_platform_data = {	\
-	.type		= PORT_SCIF,					\
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,		\
-	.flags		= UPF_BOOT_AUTOCONF | UPF_IOREMAP,		\
-	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |	\
-			  SCSCR_REIE,					\
-};									\
-									\
-static struct resource scif##index##_resources[] = {			\
-	DEFINE_RES_MEM(baseaddr, 0x100),				\
-	DEFINE_RES_IRQ(irq + 1),					\
-	DEFINE_RES_IRQ(irq + 2),					\
-	DEFINE_RES_IRQ(irq + 3),					\
-	DEFINE_RES_IRQ(irq),						\
-}									\
-
-//R7S72100_SCIF(0, 0xe8007000, gic_iid(221));	/* Not used */
-//R7S72100_SCIF(1, 0xe8007800, gic_iid(225));	/* Not used */
-R7S72100_SCIF(2, 0xe8008000, gic_iid(229));
-//R7S72100_SCIF(3, 0xe8008800, gic_iid(233));	/* Not used */
-//R7S72100_SCIF(4, 0xe8009000, gic_iid(237));	/* Not used */
-//R7S72100_SCIF(5, 0xe8009800, gic_iid(241));	/* Not used */
-//R7S72100_SCIF(6, 0xe800a000, gic_iid(245));	/* Not used */
-//R7S72100_SCIF(7, 0xe800a800, gic_iid(249));	/* Not used */
-
-#define r7s72100_register_scif(index)					       \
-	platform_device_register_resndata(&platform_bus, "sh-sci", index,      \
-					  scif##index##_resources,	       \
-					  ARRAY_SIZE(scif##index##_resources), \
-					  &scif##index##_platform_data,	       \
-					  sizeof(scif##index##_platform_data))
-
-/* OV7670 */
-static struct ov7670_config ov7670_config = {
-	.min_width =		320,	/* Filter out smaller sizes */
-	.min_height =		160,	/* Filter out smaller sizes */
-	.clock_speed =		0,	/* External clock speed (MHz) */
-	.use_smbus =		0,	/* Use smbus I/O instead of I2C */
-	.pll_bypass =		0,	/* Choose whether to bypass the PLL */
-	.pclk_hb_disable =	0,	/* Disable toggling pixclk during horizontal blanking */
-};
-
-static struct i2c_board_info ceu_camera = {
-	I2C_BOARD_INFO("ov7670", 0x21),
-};
-
-static struct soc_camera_link ceu_iclink = {
-	.bus_id = 0,
-	.board_info = &ceu_camera,
-	.i2c_adapter_id = 0,
-	.priv = &ov7670_config,
-};
-
-static const struct platform_device_info ceu_camera_info __initconst = {
-	.name = "soc-camera-pdrv",
-	.id = 0,
-	.data = &ceu_iclink,
-	.size_data = sizeof(ceu_iclink),
-};
+/* Write to I2C device */
+/* Based off of board-sx1.c */
+int rza1_i2c_write_byte(u8 ch, u8 devaddr, u8 regoffset, u8 value)
+{
+	struct i2c_adapter *adap;
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
 
-/* CEU */
-static struct sh_mobile_ceu_info sh_mobile_ceu_info = {
-	.flags = SH_CEU_FLAG_USE_8BIT_BUS,
-	.max_width = 1280,
-	.max_height = 768,
-};
+	adap = i2c_get_adapter(ch);
+	if (!adap)
+		return -ENODEV;
+	msg->addr = devaddr;	/* I2C address of chip */
+	msg->flags = 0;
+	msg->len = 2;
+	msg->buf = data;
+	data[0] = regoffset;	/* register num */
+	data[1] = value;		/* register data */
+	err = i2c_transfer(adap, msg, 1);
+	i2c_put_adapter(adap);
+	if (err >= 0)
+		return 0;
+	return err;
+}
 
-static struct resource ceu_resources[] = {
-	[0] = {
-		.name	= "CEU",
-		.start	= 0xE8210000,
-		.end	= 0xE821000f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = gic_iid(364),
-		.flags  = IORESOURCE_IRQ,
-	},
-#ifdef CONFIG_XIP_KERNEL
-	/* CEU Requires dedicated memory when in XIP mode, as there's not enough continguous
-	 * memory for the buffers. You must also specify mem=8M on the kernel command line */
-	[2] = {
-		.name	= "CEU Buffer",
-		.start	= 0x20800000,
-		.end	= 0x20A00000,
-		.flags	= IORESOURCE_MEM,
-	},
-#endif
-};
+/* Read from I2C device */
+/* Based off of board-sx1.c */
+int rza1_i2c_read_byte(u8 ch, u8 devaddr, u8 regoffset, u8 *value)
+{
+	struct i2c_adapter *adap;
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
 
-static const struct platform_device_info ceu_info __initconst = {
-	.name		= "sh_mobile_ceu",
-	.id		= 0,
-	.res		= ceu_resources,
-	.num_res	= ARRAY_SIZE(ceu_resources),
-	.data		= &sh_mobile_ceu_info,
-	.size_data	= sizeof(sh_mobile_ceu_info),
-	.dma_mask	= DMA_BIT_MASK(32),
-};
+	adap = i2c_get_adapter(ch);
+	if (!adap)
+		return -ENODEV;
 
-static struct pfc_pinmux_assign ceu_common[] = {
-	{ P11_11, ALT1, },	/* VIO_D23 */
-	{ P11_10, ALT1, },	/* VIO_D22 */
-	{ P11_9,  ALT1, },	/* VIO_D21 */
-	{ P11_8,  ALT1, },	/* VIO_D20 */
-	{ P11_7,  ALT1, },	/* VIO_D19 */
-	{ P11_6,  ALT1, },	/* VIO_D18 */
-	{ P11_5,  ALT1, },	/* VIO_D17 */
-	{ P11_4,  ALT1, },	/* VIO_D16 */
-	{ P11_3,  ALT6, },	/* VIO_D15 */
-	{ P11_2,  ALT6, },	/* VIO_D14 */
-	{ P11_1,  ALT6, },	/* VIO_D13 */
-	{ P11_0,  ALT6, },	/* VIO_D12 */
-	{ P10_15, ALT6, },	/* VIO_D11 */
-	{ P10_14, ALT6, },	/* VIO_D10 */
-	{ P10_13, ALT6, },	/* VIO_D9 */
-	{ P10_12, ALT6, },	/* VIO_D8 */
-	{ P10_11, ALT6, },	/* VIO_D7 */
-	{ P10_10, ALT6, },	/* VIO_D6 */
-	{ P10_9,  ALT6, },	/* VIO_D5 */
-	{ P10_8,  ALT6, },	/* VIO_D4 */
-	{ P10_7,  ALT6, },	/* VIO_D3 */
-	{ P10_6,  ALT6, },	/* VIO_D2 */
-	{ P10_5,  ALT6, },	/* VIO_D1 */
-	{ P10_4,  ALT6, },	/* VIO_D0 */
-	{ P10_3,  ALT6, },	/* VIO_DFLD */
-	{ P10_2,  ALT6, },	/* VIO_DHD */
-	{ P10_1,  ALT6, },	/* VIO_DVD */
-	{ P10_0,  ALT6, },	/* VIO_CLK */
-};
+	msg->addr = devaddr;	/* I2C address of chip */
+	msg->flags = 0;
+	msg->len = 1;
+	msg->buf = data;
+	data[0] = regoffset;	/* register num */
+	err = i2c_transfer(adap, msg, 1);
+	if (err < 0)
+		return err;
 
-static void ceu_pinmux(void)
-{
-	size_t n;
+	msg->addr = devaddr;	/* I2C address */
+	msg->flags = I2C_M_RD;
+	msg->len = 1;
+	msg->buf = data;
+	err = i2c_transfer(adap, msg, 1);
+	*value = data[0];
+	i2c_put_adapter(adap);
 
-	for (n = 0; n < ARRAY_SIZE(ceu_common); n++)
-		r7s72100_pfc_pin_assign(ceu_common[n].port, ceu_common[n].mode, DIIO_PBDC_EN);
+	if (err >= 0)
+		return 0;
+	return err;
 }
 
+
 static void __init rskrza1_add_standard_devices(void)
 {
 #ifdef CONFIG_CACHE_L2X0
@@ -1533,7 +1861,7 @@ static void __init rskrza1_add_standard_devices(void)
 	l2x0_init(IOMEM(0xfffee000), 0x00000000, 0xffffffff);	/* Leave as defaults */
 #endif
 #endif
-#ifdef CONFIG_XIP_KERNEL
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
 	remove_irqs();
 #endif
 
@@ -1541,6 +1869,8 @@ static void __init rskrza1_add_standard_devices(void)
 	r7s72100_pinmux_setup();
 	r7s72100_add_dt_devices();
 
+	/* ------------ Pin setup section ---------------*/
+
 	r7s72100_pfc_pin_assign(P1_15, ALT1, DIIO_PBDC_EN);	/* AD7 */
 	r7s72100_pfc_pin_assign(P1_0, ALT1, DIIO_PBDC_EN);	/* I2C SCL0 */
 	r7s72100_pfc_pin_assign(P1_1, ALT1, DIIO_PBDC_EN);	/* I2C SDA0 */
@@ -1572,7 +1902,14 @@ static void __init rskrza1_add_standard_devices(void)
 	r7s72100_pfc_pin_assign(P3_14, ALT7, DIIO_PBDC_EN);	/* SDHI1 DAT3*/
 	r7s72100_pfc_pin_assign(P3_15, ALT7, DIIO_PBDC_EN);	/* SDHI1 DAT2 */
 #endif
-	gpio_irq_init();
+
+	/* Set up IRQ for touchscreen */
+	{
+		/* Set for low edge trigger */
+		void __iomem *irc1 = IOMEM(0xfcfef802);
+		__raw_writew((__raw_readw(irc1) & ~(0x3 << 2)), irc1);
+		r7s72100_pfc_pin_assign(P4_9, ALT8, DIIO_PBDC_DIS);  /* IRQ1 */
+	}
 
 #ifdef CONFIG_CAN_RZA1
 	/* Ch 1 (conflicts with Ethernet, requires resistor change) */
@@ -1586,87 +1923,192 @@ static void __init rskrza1_add_standard_devices(void)
 	platform_device_register_full(&rz_can_device);
 #endif
 
+	/* ------------ Register Device and Drivers ---------------*/
+
 	i2c_register_board_info(0, i2c0_devices, ARRAY_SIZE(i2c0_devices));
 	i2c_register_board_info(3, i2c3_devices, ARRAY_SIZE(i2c3_devices));
 
-#ifndef CONFIG_XIP_KERNEL	/* TODO: Uses too much internal RAM */
+#if !(XIP_KERNEL_WITHOUT_EXTERNAL_RAM)	/* Uses too much internal RAM */
+#ifdef CONFIG_UOI
 	platform_device_register_full(&jcu_info);
-#endif
-	platform_device_register_full(&ostm_info);
-	platform_device_register_full(&dma_info);
-	platform_device_register_full(&alsa_soc_info);
-	platform_device_register_full(&scux_info);
-	platform_device_register_full(&ether_info);
-
-	platform_device_register_full(&riic0_info);	/* Touchscreen and camera */
-//	platform_device_register_full(&riic1_info);	/* Not used */
-//	platform_device_register_full(&riic2_info);	/* Not used */
-	platform_device_register_full(&riic3_info);	/* Port Expander, EEPROM (MAC Addr), Audio Codec */
-	platform_device_register_full(&rtc_info);
+#endif /* CONFIG_UIO */
+#endif /* XIP_KERNEL_WITHOUT_EXTERNAL_RAM */
+
+	platform_device_register_full(&ostm_info);	/* High precision OS Timer */
+	platform_device_register_full(&dma_info);	/* DMA */
+	platform_device_register_full(&alsa_soc_info);	/* Sound */
+	platform_device_register_full(&scux_info);	/* Sound */
+	platform_device_register_full(&ether_info);	/* Ethernet */
+
+	platform_device_register_full(&riic0_info);	/* I2C0: Touchscreen and camera */
+//	platform_device_register_full(&riic1_info);	/* I2C1: Not used */
+//	platform_device_register_full(&riic2_info);	/* I2C2: Not used */
+	platform_device_register_full(&riic3_info);	/* I2C3: Port Expander, EEPROM (MAC Addr), Audio Codec */
+	platform_device_register_full(&rtc_info);	/* RTC */
 
 #ifndef CONFIG_VIDEO_SH_MOBILE_CEU
-	platform_device_register_full(&vdc5fb_info);
+	platform_device_register_full(&vdc5fb0_info);	/* VDC5 ch1 */
+	//platform_device_register_full(&simplefb_info);	/* Simplefb (FLOATING LAYER) */
 #else
-	platform_device_register_full(&ceu_info);
-	platform_device_register_full(&ceu_camera_info);
+	platform_device_register_full(&ceu_info);		/* CEU */
+	platform_device_register_full(&ceu_camera_info);	/* OV7670 */
+#endif
+#ifdef USE_LVDS
+	platform_device_register_full(&vdc5fb1_info);	/* VDC5 ch1 */
 #endif
 
 #if !defined(CONFIG_XIP_KERNEL) && defined(CONFIG_SPI_SH_SPIBSC)
 	/* Need to disable both spibsc channels if using memory mapped QSPI */
-	platform_device_register_full(&spibsc0_info);
-	platform_device_register_full(&spibsc1_info);
+	platform_device_register_full(&spibsc0_info);		/* QSPI driver (non-XIP) */
+	//platform_device_register_full(&spibsc1_info);
 #else
-	platform_device_register_full(&qspi_flash_info);
+	platform_device_register_full(&qspi_flash_info);	/* Memory Mapped XIP QSPI */
 #endif
 
-	platform_device_register_full(&nor_flash_info);
+	platform_device_register_full(&nor_flash_info);		/* Parallel NOR Flash */
+
 #if 0 /* For refernce only */
 	platform_device_register_full(&pwm0_info);
 	platform_device_register_full(&pwm_backlight_info);
 	pwm_add_table(pwm_lookup, ARRAY_SIZE(pwm_lookup));
 #endif
-	platform_device_register_full(&adc0_info);
-//	platform_device_register_full(&sdhi0_info);	/* not populated on board */
+
+	platform_device_register_full(&adc0_info);	/* ADC */
+
+//	platform_device_register_full(&sdhi0_info);	/* SDHI ch0 */ /* not populated on board */
 
 #ifndef CONFIG_MMC_SDHI
-	platform_device_register_full(&mmc_info);
+	platform_device_register_full(&mmc_info);	/* MMC */
 #else
-	platform_device_register_full(&sdhi1_info);
+	platform_device_register_full(&sdhi1_info);	/* SDHI ch1 */
 #endif
 
 	if (usbgs == 0) {
-		platform_device_register_full(&r8a66597_usb_gadget0_info);
-		platform_device_register_full(&r8a66597_usb_host1_info);
+		platform_device_register_full(&r8a66597_usb_gadget0_info);	/* USB ch0 as Device */
+		platform_device_register_full(&r8a66597_usb_host1_info);	/* USB ch1 as Host */
 	} else if (usbgs == 1) {
-		platform_device_register_full(&r8a66597_usb_host0_info);
-		platform_device_register_full(&r8a66597_usb_gadget1_info);
+		platform_device_register_full(&r8a66597_usb_host0_info);	/* USB ch0 as Host */
+		platform_device_register_full(&r8a66597_usb_gadget1_info);	/* USB ch1 as Device */
 	} else {
-		platform_device_register_full(&r8a66597_usb_host0_info);
-		platform_device_register_full(&r8a66597_usb_host1_info);
+		platform_device_register_full(&r8a66597_usb_host0_info);	/* USB ch0 as Host */
+		platform_device_register_full(&r8a66597_usb_host1_info);	/* USB ch1 as Host */
 	}
 
-//	r7s72100_register_rspi(0);	/* Not used */
-//	r7s72100_register_rspi(1);	/* Not used */
-//	r7s72100_register_rspi(2);	/* Not used */
-//	r7s72100_register_rspi(3);	/* Not used */
+//	r7s72100_register_rspi(0);	/* RSPI ch0 */ /* Not used */
+//	r7s72100_register_rspi(1);	/* RSPI ch1 */ /* Not used */
+//	r7s72100_register_rspi(2);	/* RSPI ch2 */ /* Not used */
+//	r7s72100_register_rspi(3);	/* RSPI ch3 */ /* Not used */
 #if defined(RSPI_TESTING)
-	r7s72100_register_rspi(4);	/* Not used */
+	r7s72100_register_rspi(4);	/* RSPI ch4 */ /* Not used */
 #endif
 
 	/* Register SPI device information */
 	spi_register_board_info(rskrza1_spi_devices,
 				ARRAY_SIZE(rskrza1_spi_devices));
 
-//	r7s72100_register_scif(0);	/* Not used */
-//	r7s72100_register_scif(1);	/* Not used */
-	r7s72100_register_scif(2);
-//	r7s72100_register_scif(3);	/* Not used */
-//	r7s72100_register_scif(4);	/* Not used */
-//	r7s72100_register_scif(5);	/* Not used */
-//	r7s72100_register_scif(6);	/* Not used */
-//	r7s72100_register_scif(7);	/* Not used */
+//	r7s72100_register_scif(0);	/* SCIF ch0 */ /* Not used */
+//	r7s72100_register_scif(1);	/* SCIF ch1 */ /* Not used */
+	r7s72100_register_scif(2);	/* SCIF ch2 */
+//	r7s72100_register_scif(3);	/* SCIF ch3 */ /* Not used */
+//	r7s72100_register_scif(4);	/* SCIF ch4 */ /* Not used */
+//	r7s72100_register_scif(5);	/* SCIF ch5 */ /* Not used */
+//	r7s72100_register_scif(6);	/* SCIF ch6 */ /* Not used */
+//	r7s72100_register_scif(7);	/* SCIF ch7 */ /* Not used */
+
+}
+
+//#define STATS_OUT
+#ifdef STATS_OUT
+/* This function is intended to be called periodically in order to
+print out the current CPU Idle time and RAM usage with minimal
+overhead.
+
+On the RZ/A1 RSK, SCIF 1 comes out on header JA6
+	TXD1 = JA6, pin 9
+	RXD1 = JA6, pin 12
+*/
+
+/* You need to fill in how much RAM your system has so we can
+   subtract TOTAL - FREE - USED. */
+#define TOTAL_SYSTEM_RAM 0*1024 /* Total System RAM in KB */
+#if TOTAL_SYSTEM_RAM == 0
+  #error "Please define TOTAL_SYSTEM_RAM first "
+#endif
+
+/* NOTE: You need to remove 'static' from the function
+  get_idle_time() in file fs/proc/stat.c */
+u64 get_idle_time(int cpu);
+
+void print_stats(void)
+{
+	static char text[17] = " idle%,memKB\r\n";
+	static cputime64_t idle, last_idle = -1;
+	static void *scif1_base;
+
+	int ram_used = 3000, cpu_used = 10;
+	int i;
+	struct sysinfo info;
+	struct clk *scif1_clk;
+
+	/* Setup, only once */
+	if( last_idle == -1 ) {
+		/* SCIF 1 pinmux */
+		r7s72100_pfc_pin_assign(P4_12, ALT7, DIIO_PBDC_DIS);	/* SCIF1 TX */
+		r7s72100_pfc_pin_assign(P4_13, ALT7, DIIO_PBDC_DIS);	/* SCIF1 RX */
+
+		/* SCIF 1 clock */
+		scif1_clk = clk_get_sys("sh-sci.1", "sci_fck");
+		clk_enable(scif1_clk);
+
+		/* SCIF1 Registers */
+		/* Map registers so we can get at them */
+		scif1_base = ioremap_nocache(0xE8007800, 0x30);
+		#define SCFTDR_1 *(volatile uint8_t *)(scif1_base + 0x0C)
+		#define SCSCR_1 *(volatile uint16_t *)(scif1_base + 0x08)
+		#define SCBRR_1 *(volatile uint8_t *)(scif1_base + 0x04)
+
+		/* Minimum SCIF setup */
+		SCBRR_1 = 0x11;		// Baud 115200
+		SCSCR_1 = 0x0030;	// Enable TX an RX, but no interrupts
+
+		/* Print out header */
+		i = 0;
+		while(text[i++])
+		{
+			SCFTDR_1 = text[i];
+		}
+
+		//idle = kcpustat_cpu(0).cpustat[CPUTIME_IDLE];
+		idle = get_idle_time(0);
+		last_idle = get_idle_time(0);
+	}
+
+	/* Print out current CPU idle time and RAM usage */
+	si_meminfo(&info);
+
+	/* Idle time */
+	idle = get_idle_time(0);
+	cpu_used = (last_idle - idle)*100;
+	cpu_used = cpu_used / 132;
+	if( cpu_used >= 99)
+		cpu_used = 99;
+	last_idle = idle;
 
+	/* USED_RAM = TOTAL_RAM - FREE_RAM */
+	ram_used = TOTAL_SYSTEM_RAM - (info.freeram << (PAGE_SHIFT - 10));
+
+	sprintf(text,"%03d%%,%04dKB\r\n",cpu_used,ram_used);
+
+	/* We want the string to be less than 16 characters so all fits
+	   in the 16byte SCIF FIFO */
+	i=0;
+	while(text[i++])
+	{
+		SCFTDR_1 = text[i];
+	}
 }
+#endif
+
 
 static int heartbeat(void * data)
 {
@@ -1687,6 +2129,12 @@ static int heartbeat(void * data)
 			rza1_i2c_write_byte(3, 0x20, 0x01, value);
 
 		msleep_interruptible(250);
+
+#ifdef STATS_OUT
+		/* Only print stats once per second */
+		if( (index & 0x03) == 0 )
+			print_stats();
+#endif
 	}
 
 	return 0;
@@ -1716,7 +2164,7 @@ static void __init rskrza1_init_late(void)
 			i = rza1_i2c_write_byte(3, 0x21, 0x01, value);
 		if ( !i ) {
 			/* Enable SPI4 pins */
-			/* RSKRZA1 Board SPI4 is on CN15 (but that means you can use Ethernet) */
+			/* RSKRZA1 Board SPI4 is on CN15 (but that means you can't use Ethernet) */
 			r7s72100_pfc_pin_assign(P2_8, ALT8, DIIO_PBDC_EN);	/* RSPCK4 */
 			r7s72100_pfc_pin_assign(P2_9, ALT8, DIIO_PBDC_EN);	/* SSL40 */
 			r7s72100_pfc_pin_assign(P2_10, ALT8, DIIO_PBDC_EN);	/* MOSI4 */
@@ -1743,17 +2191,23 @@ static void __init rskrza1_init_late(void)
 	}
 #endif
 
-	/* Start heardbeat kernel thread */
+	/* Start heartbeat kernel thread */
 	kthread_run(heartbeat, NULL,"heartbeat");
 }
 
 #define WTCSR 0
 #define WTCNT 2
 #define WRCSR 4
-static void rskrza1_restart(enum reboot_mode mode, const char *cmd)
+static void r7s72100_restart(enum reboot_mode mode, const char *cmd)
 {
 	void *base = ioremap_nocache(0xFCFE0000, 0x10);
 
+	/* If you have board specific stuff to do, you can do it
+	   here before you reboot */
+
+	/* NOTE: A reboot command doesn't 'sync' before this function
+	   is called. See funciotn reboot() in kernel/reboot.c */
+
 	/* Dummy read (must read WRCSR:WOVF at least once before clearing) */
 	*(volatile uint8_t *)(base + WRCSR) = *(uint8_t *)(base + WRCSR);
 
@@ -1769,7 +2223,7 @@ void __init r7s72100_init_early(void)
 {
 	shmobile_init_delay();
 
-#ifdef CONFIG_XIP_KERNEL
+#if XIP_KERNEL_WITHOUT_EXTERNAL_RAM
 	/* Set the size of our pre-allocated DMA buffer pool because the
 	   default is 256KB */
 	init_dma_coherent_pool_size(16 * SZ_1K);
@@ -1786,6 +2240,6 @@ DT_MACHINE_START(RSKRZA1_DT, "rskrza1")
 	.init_machine	= rskrza1_add_standard_devices,
 	.init_late	= rskrza1_init_late,
 	.dt_compat	= rskrza1_boards_compat_dt,
-	.map_io		= rza1_map_io,
-	.restart	= rskrza1_restart,
+	.map_io		= r7s72100_map_io,
+	.restart	= r7s72100_restart,
 MACHINE_END
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index c348f75..6d2e7a7 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -1365,7 +1365,11 @@ static void __init kmap_init(void)
 static void __init map_lowmem(void)
 {
 	struct memblock_region *reg;
+#ifdef CONFIG_XIP_KERNEL
+	unsigned long kernel_x_start = round_down(__pa(_sdata), SECTION_SIZE);
+#else
 	unsigned long kernel_x_start = round_down(__pa(_stext), SECTION_SIZE);
+#endif
 	unsigned long kernel_x_end = round_up(__pa(__init_end), SECTION_SIZE);
 
 	/* Map all the lowmem memory banks. */
diff --git a/drivers/input/touchscreen/ft5x06_ts.c b/drivers/input/touchscreen/ft5x06_ts.c
index e29b8b3..2f5bb37 100644
--- a/drivers/input/touchscreen/ft5x06_ts.c
+++ b/drivers/input/touchscreen/ft5x06_ts.c
@@ -90,6 +90,7 @@ module_param_array(calibration, int, NULL, S_IRUGO | S_IWUSR);
 static int screenres[2] = {1280, 800};
 module_param_array(screenres, int, NULL, S_IRUGO | S_IWUSR);
 
+#ifndef CONFIG_MACH_RSKRZA1	/* not used for the RSK BSP */
 static void translate(int *px, int *py)
 {
 	int x, y, x1, y1;
@@ -113,6 +114,7 @@ static void translate(int *px, int *py)
 		*py = y ;
 	}
 }
+#endif
 
 static inline void ts_evt_add(struct ft5x06_ts *ts,
 			                  unsigned buttons, struct point *p)
@@ -194,8 +196,10 @@ static void read_report(struct ft5x06_ts *ts)
 	}	
 		
 	p = buf + 3; 
-	buttons = buf[2];
-	
+	buttons = buf[2] & 0x07;	/* Only look at the lower 3 bits because after power on,
+					   sometimes the upper bits are not '0's until the first
+					   physical touch */
+
 	if (buttons > 5) {
 		printk(KERN_ERR 
 		       "%s: invalid button count %02x\n",
diff --git a/drivers/video/renesas/vdc5fb-regs.h b/drivers/video/renesas/vdc5fb-regs.h
index 28c6334..2ba244e 100644
--- a/drivers/video/renesas/vdc5fb-regs.h
+++ b/drivers/video/renesas/vdc5fb-regs.h
@@ -1021,7 +1021,7 @@ static const char *irq_names[VDC5FB_MAX_IRQS] = {
 #define	GR_FLM_LNUM(x)		(((x) & 0x7ffu) << 16)
 /* GRx_FLM6, GR_OIR_FLM6 */
 //#define	GR_RDSWA(x)		(((x) & 0x7u) << 10)	/* moved to vdc5.h */
-#define	GR_HW(x)		(((x) & 0x3ff) << 16)
+#define	GR_HW(x)		(((x) & 0x7ff) << 16)
 //#define	GR_FORMAT(x)		(((x) & 0xfu) << 28)	/* moved to vdc5.h */
 #define	D_GR_FLM6_RGB565	(GR_RDSWA(6) | GR_FORMAT(0))
 #define	D_GR_FLM6_RGB888	(GR_RDSWA(4) | GR_FORMAT(1))
@@ -1088,11 +1088,15 @@ static const char *irq_names[VDC5FB_MAX_IRQS] = {
 /* IMGCNT_UPDATE */
 #define	IMGCNT_VEN		(1u << 0)
 /* SCx_SCLx_UPDATE, GRx_UPADTE, OIR_SCLx_UPDATE (x=0,1) */
-#define	SC_SCL_VEN_A		(1u << 0)
-#define	SC_SCL_VEN_B		(1u << 4)
-#define	SC_SCL_UPDATE		(1u << 8)
-#define	SC_SCL_VEN_C		(1u << 12)	/* not OIR_SCL1_UPDATE */
-#define	SC_SCL_VEN_D		(1u << 13)	/* not OIR_SCL1_UPDATE */
+#define	SC_SCL0_VEN_A		(1u << 0)
+#define	SC_SCL0_VEN_B		(1u << 4)
+#define	SC_SCL0_UPDATE		(1u << 8)
+#define	SC_SCL0_VEN_C		(1u << 12)	/* not OIR_SCL1_UPDATE */
+#define	SC_SCL0_VEN_D		(1u << 13)	/* not OIR_SCL1_UPDATE */
+#define	SC_SCL1_VEN_A		(1u << 0)
+#define	SC_SCL1_VEN_B		(1u << 4)
+#define	SC_SCL1_UPDATE_A	(1u << 16)
+#define	SC_SCL1_UPDATE_B	(1u << 20)
 /* ADJx_UPDATE */
 #define	ADJ_VEN			(1u << 0)
 /* GRx_UPDATE, GR_OIR_UPDATE (x=2,3) */
diff --git a/drivers/video/renesas/vdc5fb.c b/drivers/video/renesas/vdc5fb.c
index 0048f08..2fbe3b8 100644
--- a/drivers/video/renesas/vdc5fb.c
+++ b/drivers/video/renesas/vdc5fb.c
@@ -55,7 +55,7 @@ struct vdc5fb_priv {
 	struct fb_videomode *videomode;	/* current */
 	/* clock */
 	struct clk *clk;
-	struct clk *dot_clk;
+	struct clk *p1_clk;
 	struct clk *lvds_clk;
 	/* framebuffers */
 	void __iomem *base;
@@ -206,11 +206,11 @@ static int vdc5fb_init_clocks(struct vdc5fb_priv *priv)
 		return PTR_ERR(priv->clk);
 	}
 
-	priv->dot_clk = clk_get(&pdev->dev, clkname_p1clk);
-	if (IS_ERR(priv->dot_clk)) {
+	priv->p1_clk = clk_get(&pdev->dev, clkname_p1clk);
+	if (IS_ERR(priv->p1_clk)) {
 		dev_err(&pdev->dev, "cannot get clock \"%s\"\n", clkname_p1clk);
 		clk_put(priv->clk);
-		return PTR_ERR(priv->dot_clk);
+		return PTR_ERR(priv->p1_clk);
 	}
 
 	if (pdata->use_lvds) {
@@ -219,7 +219,7 @@ static int vdc5fb_init_clocks(struct vdc5fb_priv *priv)
 			dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
 				clkname_lvds);
 			clk_put(priv->clk);
-			clk_put(priv->dot_clk);
+			clk_put(priv->p1_clk);
 			return PTR_ERR(priv->lvds_clk);
 		}
 	}
@@ -231,8 +231,8 @@ static void vdc5fb_deinit_clocks(struct vdc5fb_priv *priv)
 {
 	if (priv->lvds_clk)
 		clk_put(priv->lvds_clk);
-	if (priv->dot_clk)
-		clk_put(priv->dot_clk);
+	if (priv->p1_clk)
+		clk_put(priv->p1_clk);
 	if (priv->clk)
 		clk_put(priv->clk);
 }
@@ -268,17 +268,20 @@ static int vdc5fb_update_regs(struct vdc5fb_priv *priv,
 	vdc5fb_write(priv, reg, tmp);
 
 	if (wait) {
-		timeout = 50;
+		timeout = 100;
 		do {
 			tmp = vdc5fb_read(priv, reg);
 			if ((tmp & bits) == 0)
 				return 0;
 			udelay(1000);
 		} while (--timeout > 0);
-	/* wait for max. 50 ms... */
+	/* wait for max. 100 ms... */
 	}
-	dev_err(&priv->pdev->dev, "update_regs timeout at %d in %s\n",
-		__LINE__, __func__);
+	dev_err(&priv->pdev->dev, "update_regs timeout reg=%08lX, bits=%08lX, now=%08lX\n",
+		VDC5FB_REG_BASE(0) + vdc5fb_offsets[reg],
+		(long unsigned int)bits,
+		(long unsigned int)tmp);
+
 	return -1;
 }
 
@@ -287,18 +290,25 @@ static int vdc5fb_update_regs(struct vdc5fb_priv *priv,
 static int vdc5fb_set_panel_clock(struct vdc5fb_priv *priv,
 	struct fb_videomode *mode)
 {
+	/* These are the divide by ratios for DCDR[5:0] */
 	static const unsigned char dcdr_list[13] = {
 		1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 16, 24, 32,
 	};
-	uint64_t desired64 = 1000000000000;
+
+	uint64_t desired64 = 1000000000000; /* pixclock is in ps (pico seconds)*/
 	unsigned long desired;
 	unsigned long source;
 	unsigned long used;
 	int n;
 
-	source = clk_get_rate(priv->dot_clk);
+	/* NOTE: This assumes your clock source will be P1 */
+	source = clk_get_rate(priv->p1_clk);
 	BUG_ON(source == 0);
 
+	/* The board file will set fb_videomode.pixclock to what the panel
+	   recomends, but should be a division of P1 clock. Now we need
+	   to find out what divider bits for DCDR need to be (knowing that the 
+	   DCDR has a limited number of valid divider) */
 	(void)do_div(desired64, mode->pixclock);
 	desired = (unsigned long)desired64;
 	for (n = 0; n < ARRAY_SIZE(dcdr_list); n++) {
@@ -319,60 +329,116 @@ static int vdc5fb_set_panel_clock(struct vdc5fb_priv *priv,
 static int vdc5fb_init_lvds(struct vdc5fb_priv *priv)
 {
 	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
-	uint64_t desired64 = 1000000000000;
+	uint64_t desired64 = 1000000000000; /* pixclock is in ps (pico seconds)*/
 	u32 desired, source, fref, nfd, fvco, i, nod, nod_array[4], fout;
 	u32 tmp;
 
+	/*	
+	(Figure 40.3 from manual)
+	Source-->NIDIV-->NRD--+-->VCO--+-->NOD--+-->NODIV-->Panel clock
+	                      +--NFD<--+        +-->Freq divider 3-->Panel clock LVDS
+                                                +------------------->Clock for LVDS output
+		NIDIV = frequency divider 1
+		NODIV = frequency divider 2
+		NRD = input frequency divider
+		NFD = feedback frequency divider
+		NOD = output frequency divider
+
+		FIN = Source / NIDIV (output of divider 1) (9 MHz to 30 MHz)
+		FREF = FIN / NRD (Reference frequency)	(2.5 MHz to 30 MHz)
+		FVCO = FIN  NFD / NRD (VCO output frequency ) (750 MHz to 1630 MHz)
+		FOUT = FIN  NFD / (NRD  NOD) (LVDS PLL output frequency ) (609 MHz max)
+
+	*/
 	/*
-	  To semplify:
+	  To simplify:
 	   - fix input clock to peripheral1 = 66650000 Hz
+		LVDS_IN_CLK_SEL = 5 (P1 CLK)
 	   - fix NIDIV to 4 => FIN = source / 4 = 16662500 Hz
+		LVDS_IDIV_SET = 2 (NIDIV = 4)
 	   - fix NRD to 5 => FREF = FIN / 5 = source / 20 = 3332500 Hz
-	   - evaluate fout according icksel
+	   - evaluate fout according ocksel
 	   - evaluate NOD to allow fvco be the nearest to 1.1 GHz [sqrt(750*1630) MHz]
 	*/
 
-	source = clk_get_rate(priv->dot_clk);
+	/* LVDS Clock Select Register (LCLKSELR) Settings */
+	#define MY_LVDS_SET_IN_CLK_SEL	VDC5_LVDS_INCLK_SEL_PERI /* P1 Clock (fixed) */
+	#define MY_LVDS_IDIV_SET	VDC5_LVDS_NDIV_4	/* NIDIV = div by 4 */
+	#define MY_LVDS_ODIV_SET	VDC5_LVDS_NDIV_4	/* NODIV = div by 4 */
+
+	/* LVDS PLL Setting Register (LPLLSETR) Settings */
+	/* LVDSPLL_FD is run-time calucalted */			/* NFD = ??? */
+	#define MY_LVDSPLL_RD	4				/* NRD = div by 5 */
+	/* LVDSPLL_OD is run-time calucalted */			/* NOD = ??? */
+
+
+	/* Source is P1 Clock (fixed) */
+	source = clk_get_rate(priv->p1_clk);
 	BUG_ON(source == 0);
-	fref = source / 20;
 
+	/* Calculate FREF */
+	/* FREF = FIN / NRD */
+	fref = source / (1 << MY_LVDS_IDIV_SET);
+	fref = fref / (MY_LVDSPLL_RD + 1);
+
+	/* Convert pixclock in ps to hertz */
 	(void)do_div(desired64, pdata->videomode->pixclock);
 	desired = (unsigned long)desired64;
+ 
+	fout = desired;		/* our desired panel clock */
 
-	fout = desired;		/* desired */
-	if (pdata->panel_icksel == OCKSEL_PLL_DIV7)
+	/* The LVDS transmition rate (raw PLL output) will be 7x
+	   the panel clock */
+	if (pdata->panel_ocksel == OCKSEL_PLL_DIV7)
 		fout *= 7;
 
+	/* Calcualte NOD */
+	/* Find a VCO output frequncy that gets us as close to 1.1GHz
+	   [sqrt(750*1630) MHz] as possible (over or under). Try
+	   all 4 possible NOD values
+	   NOD = 2 ^ LVDSPLL_OD */
 	for (i = 0, nod = 0; i < 4; i++) {
+		/* How many times does 1.1GHz need to be halved
+		   in order to equal fout? */
 		nod_array[i] = (1105667219 >> i) - fout;
 		if (nod_array[i] < 0)
 			nod_array[i] = -nod_array[i];
 		if (nod_array[i] < nod_array[nod])
-			nod = i;
+			nod = i;	/* the closest value (+ or -) */
 	}
 
-	fvco = fout * (1 << nod);	/* desired */
+	/* Our desired FVCO based on our desire pixelclock */
+	fvco = fout * (1 << nod);	/* desired fvco */
 
-	/* real values */
+	/* Determine our real values based on true clock source (FREF) */
 	nfd = ROUNDED_DIV(fvco, fref);
-	fvco = fref * nfd;
-	fout = fvco / (1 << nod);
+	fvco = fref * nfd;		/* real fvco */
+	fout = fvco / (1 << nod);	/* real fout */
 
+	/* Clock Frequency Division Ratio of the VDC5 channel is fixed
+	   to 1:1 (since we are doing all the work here to make sure
+	   the panel clock is a good value) */
 	priv->dcdr = 1;
+
 	priv->dc = fout;
-	if (pdata->panel_icksel == OCKSEL_PLL_DIV7)
+
+	/* Panel dot clock is 1/7 of LVDS tx clock */
+	if (pdata->panel_ocksel == OCKSEL_PLL_DIV7)
 		priv->dc /= 7;
 
+	/* Print out values for user to confirm frequencies are
+	   within correct ranges */
 	dev_dbg(&priv->pdev->dev,
-		"LVDS: Fref %u Hz, NFD %u, Fvco %u Hz, nod 1/%u, Fout %u MHz\n",
-		fref, nfd, fvco, 1 << nod, fout);
+		"LVDS: target %u Hz, actual %lu Hz, Fref %u Hz, NFD %u, Fvco %u Hz, nod 1/%u, Fout %u Hz\n",
+		desired, priv->dc, fref, nfd, fvco, 1 << nod, fout);
 
 	tmp = vdc5fb_read(priv, SYSCNT_PANEL_CLK);
 	tmp &= ~PANEL_ICKEN;
 	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
 
-#if 0
+#if 1
 	/* Specify the characteristics of LVDS output buffer: LPHYACC.SKEWC[1:0] = 01 */
+	/* As required by hardware manual */
 	tmp = vdc5fb_read(priv, LPHYACC);
 	tmp &= ~0x0003;
 	tmp |= 0x0001;
@@ -380,23 +446,25 @@ static int vdc5fb_init_lvds(struct vdc5fb_priv *priv)
 #endif
 
 	/* LCLKSELR: LVDS clock select register */
+
+	/* Mask bits to 0 */
 	tmp = vdc5fb_read(priv, LCLKSELR);
 	tmp &= ~LVDS_LCLKSELR_MASK;
 	vdc5fb_write(priv, LCLKSELR, tmp);
 
 	/* The clock input to frequency divider 1 */
-	tmp |= LVDS_SET_IN_CLK_SEL(VDC5_LVDS_INCLK_SEL_PERI);
+	tmp |= LVDS_SET_IN_CLK_SEL(MY_LVDS_SET_IN_CLK_SEL);
 	vdc5fb_write(priv, LCLKSELR, tmp);
 
 	/* The frequency dividing value (NIDIV) for frequency divider 1 */
-	tmp |= LVDS_SET_IDIV(VDC5_LVDS_NDIV_4);
+	tmp |= LVDS_SET_IDIV(MY_LVDS_IDIV_SET);
 	vdc5fb_write(priv, LCLKSELR, tmp);
 
 	/* The frequency dividing value (NODIV) for frequency divider 2 */
-	tmp |= LVDS_SET_ODIV(VDC5_LVDS_NDIV_4);
+	tmp |= LVDS_SET_ODIV(MY_LVDS_ODIV_SET);
 	vdc5fb_write(priv, LCLKSELR, tmp);
 
-	/* A channel in VDC5 whose data is to be output through the LVDS */
+	/* The VDC5 channel whose data is to be output through the LVDS */
 	if (priv->pdev->id)
 		tmp |= LVDS_VDC_SEL;
 	vdc5fb_write(priv, LCLKSELR, tmp);
@@ -413,7 +481,7 @@ static int vdc5fb_init_lvds(struct vdc5fb_priv *priv)
 	vdc5fb_write(priv, LPLLSETR, tmp);
 
 	/* The frequency dividing value (NRD) for the input frequency */
-	tmp |= LVDS_SET_RD(0x0004);
+	tmp |= LVDS_SET_RD(MY_LVDSPLL_RD);
 	vdc5fb_write(priv, LPLLSETR, tmp);
 
 	/* The frequency dividing value (NOD) for the output frequency */
@@ -468,8 +536,8 @@ static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv)
 	/* Setup panel clock */
 	tmp = PANEL_DCDR(priv->dcdr);
 	tmp |= PANEL_ICKEN;
-	tmp |= PANEL_OCKSEL(pdata->use_lvds ? pdata->panel_icksel : 0);
-	tmp |= PANEL_ICKSEL(pdata->use_lvds ? 0: pdata->panel_icksel);
+	tmp |= PANEL_OCKSEL(pdata->panel_ocksel);
+	tmp |= PANEL_ICKSEL(pdata->panel_icksel);
 	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
 
 	return 0;
@@ -544,7 +612,7 @@ static int vdc5fb_init_sync(struct vdc5fb_priv *priv)
 	vdc5fb_write(priv, GR_VIN_AB1, tmp);
 
 	/* Do update here. */
-	tmp = (SC_SCL_UPDATE | SC_SCL_VEN_B);
+	tmp = (SC_SCL0_UPDATE | SC_SCL0_VEN_B);
 	vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, tmp, 1);
 	vdc5fb_update_regs(priv, SC1_SCL0_UPDATE, tmp, 1);
 #ifdef OUTPUT_IMAGE_GENERATOR
@@ -565,7 +633,7 @@ static int vdc5fb_init_scalers(struct vdc5fb_priv *priv)
 	/* Enable and setup scaler 0 */
 	if( priv->pdata->layers[0].xres ) {
 		vdc5fb_write(priv, SC0_SCL0_FRC3, SC_RES_VS_SEL);
-		vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, SC_SCL_UPDATE, 1);
+		vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, SC_SCL0_UPDATE, 1);
 
 		vdc5fb_write(priv, SC0_SCL0_DS1, 0);
 		vdc5fb_write(priv, SC0_SCL0_US1, 0);
@@ -599,7 +667,7 @@ static int vdc5fb_init_scalers(struct vdc5fb_priv *priv)
 	/* Enable and setup scaler 1 */
 	if( priv->pdata->layers[1].xres ) {
 		vdc5fb_write(priv, SC1_SCL0_FRC3, SC_RES_VS_SEL);
-		vdc5fb_update_regs(priv, SC1_SCL0_UPDATE, SC_SCL_UPDATE, 1);
+		vdc5fb_update_regs(priv, SC1_SCL0_UPDATE, SC_SCL0_UPDATE, 1);
 
 		vdc5fb_write(priv, SC1_SCL0_DS1, 0);
 		vdc5fb_write(priv, SC1_SCL0_US1, 0);
@@ -721,14 +789,15 @@ static int vdc5fb_init_graphics(struct vdc5fb_priv *priv)
 			continue;
 		}
 
-		printk("vdc5fb: Layer %u Enabled (%ux%u)\n",i,layer->xres,layer->yres);
-
 		vdc5fb_iowrite32(GR_R_ENB, update_addr[i] + GR_FLM_RD_OFFSET);
 		vdc5fb_iowrite32(GR_FLM_SEL(1), update_addr[i] + GR_FLM1_OFFSET); /* scalers MUST use FLM_SEL */
 		if( layer->base == 0 )
 			layer->base = priv->dma_handle;	/* Allocated during probe */
 		if( layer->base >= 0xC0000000 )
 			layer->base = virt_to_phys((void *)layer->base);	/* Convert to physical address */
+
+		printk("vdc5fb: Layer %u Enabled (%ux%u @ 0x%08x)\n",i,layer->xres,layer->yres, layer->base);
+
 		vdc5fb_iowrite32(layer->base, update_addr[i] + GR_FLM2_OFFSET);	/* frame buffer address*/
 		tmp = GR_LN_OFF(layer->xres * (layer->bpp / 8));	/* length of each line (and Frame Number=0)*/
 		vdc5fb_iowrite32(tmp, update_addr[i] + GR_FLM3_OFFSET);
@@ -986,9 +1055,12 @@ static int vdc5fb_update_all(struct vdc5fb_priv *priv)
 	tmp = IMGCNT_VEN;
 	vdc5fb_update_regs(priv, IMGCNT_UPDATE, tmp, 1);
 
-	tmp = (SC_SCL_VEN_A | SC_SCL_VEN_B | SC_SCL_UPDATE
-		| SC_SCL_VEN_C | SC_SCL_VEN_D);
+	tmp = (SC_SCL0_VEN_A | SC_SCL0_VEN_B | SC_SCL0_UPDATE
+		| SC_SCL0_VEN_C | SC_SCL0_VEN_D);
 	vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, tmp, 1);
+
+	tmp = (SC_SCL1_VEN_A | SC_SCL1_VEN_B | SC_SCL1_UPDATE_A
+		| SC_SCL1_UPDATE_B);
 	vdc5fb_update_regs(priv, SC0_SCL1_UPDATE, tmp, 1);
 
 	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
@@ -1042,10 +1114,17 @@ static void vdc5fb_set_videomode(struct vdc5fb_priv *priv,
 	if (priv->info->screen_base)	/* sanity check */
 		vdc5fb_clear_fb(priv);
 
-	if (pdata->use_lvds)
+	if (pdata->use_lvds) {
 		vdc5fb_init_lvds(priv);
-	else if (vdc5fb_set_panel_clock(priv, mode) < 0)
-		dev_err(&priv->pdev->dev, "cannot get dcdr\n");
+	}
+	else {
+		/* This driver assumes P1 clock will always be used
+		   as the panel clock source for both RGB and LVDS */
+		BUG_ON( pdata->panel_icksel != ICKSEL_P1CLK);
+
+		if (vdc5fb_set_panel_clock(priv, mode) < 0)
+				dev_err(&priv->pdev->dev, "cannot get dcdr\n");
+	}
 
 	dev_info(&priv->pdev->dev,
 		"%s: [%s] dotclock %lu.%03u MHz, dcdr %u\n",
@@ -1468,8 +1547,8 @@ static int vdc5fb_start(struct vdc5fb_priv *priv)
 	if (error < 0)
 		return error;
 
-	if (priv->dot_clk) {
-		error = clk_enable(priv->dot_clk);
+	if (priv->p1_clk) {
+		error = clk_enable(priv->p1_clk);
 		if (error < 0)
 			return error;
 	}
@@ -1487,8 +1566,8 @@ static int vdc5fb_start(struct vdc5fb_priv *priv)
 
 static void vdc5fb_stop(struct vdc5fb_priv *priv)
 {
-	if (priv->dot_clk)
-		clk_disable(priv->dot_clk);
+	if (priv->p1_clk)
+		clk_disable(priv->p1_clk);
 	if (priv->lvds_clk)
 		clk_disable(priv->lvds_clk);
 	clk_disable(priv->clk);
@@ -1545,7 +1624,18 @@ static int vdc5fb_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "cannot get resources (reg)\n");
 		goto err1;
 	}
-	priv->base = ioremap_nocache(res->start, resource_size(res));
+
+	/* Because the LVDS registers sit between ch0 and ch1, we need to
+	   map both ch0 and ch1 areas if the ch1 wants to use LVDS.
+	   See function vdc5fb_read() and vdc5fb_write() */
+	if( priv->pdev->id && pdata->use_lvds) {
+		priv->base = ioremap_nocache(res->start - 0x2000, resource_size(res) + 0x2000);
+		priv->base += 0x2000;	/* Adjust back to start of ch0 registers */
+		/* NOTE: iounmapping priv->base won't be correct at this point */
+	}
+	else {
+		priv->base = ioremap_nocache(res->start, resource_size(res));
+	}
 	priv->fbsize = resource_size(res);
 	if (!priv->base) {
 		dev_err(&pdev->dev, "cannot ioremap (reg)\n");
diff --git a/include/video/vdc5fb.h b/include/video/vdc5fb.h
index 79906bc..3d96b5c 100644
--- a/include/video/vdc5fb.h
+++ b/include/video/vdc5fb.h
@@ -40,14 +40,6 @@
 #define	VDC5FB_IRQ_BASE(x)	(75 + (24 * (x)))
 #define	VDC5FB_IRQ_SIZE		23
 
-/* clock_source */
-enum {
-	ICKSEL_INPSEL = 0,
-	ICKSEL_EXTCLK0,
-	ICKSEL_EXTCLK1,
-	ICKSEL_P1CLK,
-};
-
 /* tcon_sel */
 enum {				/* index */
 	LCD_TCON0 = 0,
@@ -103,11 +95,28 @@ struct vdc5fb_layer {
 	u32 blend;	/* blend with lower layer or not */
 };
 
-/*! The clock input to vdc5 */
+/* Choices for ".panel_icksel".
+  When .use_lvds=0:
+    This driver only supports ICKSEL_P1CLK because the math to
+    calculate PANEL_DCDR[5:0] assumes a P1 clock rate.
+  When .use_lvds=1
+    This value is not used (PANEL_ICKSEL[1:0] is don't care when using LVDS)
+  See "Panel Clock Control Register (SYSCNT_PANEL_CLK)" for more details */
+enum {
+	ICKSEL_INPSEL = 0,	/* Video image clock (VIDEO_X1 or DV_CLK based on INP_SEL=0,1) */
+	ICKSEL_EXTCLK0,		/* External clock (LCD0_EXTCLK) */
+	ICKSEL_EXTCLK1,		/* External clock (LCD1_EXTCLK) */
+	ICKSEL_P1CLK,		/* Peripheral clock 1 */
+};
+
+/* Choices for ".panel_ocksel".
+  When .use_lvds=0, only OCKSEL_ICK should be selected
+  When .use_lvds=1, OCKSEL_PLL or OCKSEL_PLL_DIV7 should be selected
+  See "Panel Clock Control Register (SYSCNT_PANEL_CLK)" for more details */
 enum {
-	OCKSEL_ICK = 0,
-	OCKSEL_PLL,
-	OCKSEL_PLL_DIV7,
+	OCKSEL_ICK = 0,		/* Selected by PANEL_CLK[1:0] */
+	OCKSEL_PLL,		/* LVDS PLL clock */
+	OCKSEL_PLL_DIV7,	/* LVDS PLL clock divided by 7 */
 };
 
 /*! The clock input to frequency divider 1 */
@@ -121,6 +130,7 @@ enum {
 	VDC5_LVDS_INCLK_SEL_NUM
 };
 
+/*! The frequency divider 1 (NIDIV) and frequency divider 2 (NODIV) */
 enum {
 	VDC5_LVDS_NDIV_1 = 0,		/*!< Div 1 */
 	VDC5_LVDS_NDIV_2,		/*!< Div 2 */
@@ -142,7 +152,8 @@ struct vdc5fb_pdata {
 	const char *name;
 	struct fb_videomode *videomode;
 	int bpp;		/* should be 16 or 32 */
-	int panel_icksel;	/* should be ICKSEL_P1CLK */
+	int panel_icksel;	/* should be ICKSEL_XXX */
+	int panel_ocksel;	/* should be OCKSEL_XXX */
 	unsigned long panel_width;
 	unsigned long panel_height;
 	unsigned long flm_max;
diff --git a/sound/soc/codecs/max9856.c b/sound/soc/codecs/max9856.c
index 1ee593e..2e2e9c8 100644
--- a/sound/soc/codecs/max9856.c
+++ b/sound/soc/codecs/max9856.c
@@ -367,7 +367,7 @@ static int max9856_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 		return -EINVAL;
 	}
 
-	snd_soc_update_bits(codec, MAX9856_DAC_SYS, 0xF8, dac_sys);
+	snd_soc_update_bits(codec, MAX9856_DAC_SYS, 0xFC, dac_sys);
 	snd_soc_update_bits(codec, MAX9856_ADC_SYS, 0xC8, adc_sys);
 	snd_soc_update_bits(codec, MAX9856_CLOCK, MAX9856_CLOCK_MAS, clock);
 
